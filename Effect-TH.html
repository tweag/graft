<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Effect.TH</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">graft-0.0.0</span><ul class="links" id="page-menu"><li id="quick-jump-button"><a href="#">Quick Jump</a></li><li><a href="src/Effect.TH.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Effect.TH</p></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:defineEffectType">defineEffectType</a> :: <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>]</li><li class="src short"><a href="#v:makeEffect">makeEffect</a> :: <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>]</li><li class="src short"><a href="#v:makeReification">makeReification</a> :: ([<a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>] -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Type" title="Language.Haskell.TH.Syntax">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>]</li><li class="src short"><a href="#v:makeInterpretation">makeInterpretation</a> :: ([<a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>] -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Type" title="Language.Haskell.TH.Syntax">Type</a>) -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>]</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:defineEffectType" class="def">defineEffectType</a> :: <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>] <a href="src/Effect.TH.html#defineEffectType" class="link">Source</a> <a href="#v:defineEffectType" class="selflink">#</a></p><div class="doc"><p>Generate the effect type corresponding to a class.</p><p>By, example, given</p><pre>class (...) =&gt; Foo a b m where
  foo :: a -&gt; b -&gt; m ()
  bar :: forall c. Ord c =&gt; (c -&gt; m a) -&gt; b -&gt; m (c, Bool)</pre><p>the macro</p><pre>defineEffectType ''Foo</pre><p>writes an effect type like</p><pre>data FooEffect a b :: Effect where
  Foo :: a -&gt; b -&gt; FooEffect a b m ()
  Bar :: forall c. Ord c =&gt; (c -&gt; m a) -&gt; b -&gt; FooEffect a b m (c, Bool)</pre><p>There are two naming conventions here:</p><p><strong>naming convention 1</strong>: The effect type corresponding to the class <code>X</code> is
 called <code>XEffect</code>. For example, <code>MonadError</code> corresponds to
 <code>MonadErrorEffect</code>.</p><p><strong>naming convention 2</strong>: The names of the constructors of <code>XEffect</code> must be
 exactly the names of the methods of the class <code>X</code>, just starting with an
 upper-case letter.</p><p>This macro furhtermore assumes that the last type variable in the the class
 definition (here, that's <code>m</code>) is of kind <code>Type -&gt; Type</code>.  This makes sense
 for our application, because our classes will normally be classes of monads.</p></div></div><div class="top"><p class="src"><a id="v:makeEffect" class="def">makeEffect</a> :: <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>] <a href="src/Effect.TH.html#makeEffect" class="link">Source</a> <a href="#v:makeEffect" class="selflink">#</a></p><div class="doc"><p>Automatically write &quot;reification&quot; and &quot;interpretation&quot; instances for an
 effect type and its associated class of monads.</p><p>Assume a class definition like</p><pre>class (SomeConstraint a, MonadBar b m) =&gt; MonadFoo a b m</pre><p>and an effect type defined like</p><pre>data MonadFooEffect a b :: Effect</pre><p>Then the macro</p><pre>makeEffect ''MonadFoo ''MonadFooEffect</pre><p>will expand into two instance definitions:</p><ol><li value="1">The &quot;reification&quot; instance</li></ol><pre>instance (SomeConstraint a,
          EffectInject (MonadBarEffect b) ops,
          EffectInject (MonadFooEffect a b) ops)
  =&gt; MonadFoo a b (AST ops)</pre><p>says that an <code><a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a></code> whose list <code>ops</code> of effect types contains
 <code>MonadFooEffect</code> is a <code>MonadFoo</code>. In order for this instance to make sense,
 though, we'll have to add at least satisfy the constraints that were already
 there on the class definition of <code>MonadFoo</code>. Therefore, we have to add</p><ul><li><code>SomeConstraint a</code>,</li><li>a constraint that implies <code>MonadBar b (AST ops)</code>: That is the reason for
   the constraint <code>EffectInject (MonadBarEffect b) ops</code>. This macro assumes
   that the only way for an <code><a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a></code> to become a <code>MonadX</code> for some <code>X</code> is to
   contain the correct effect type <code>MonadXEffect</code>. That is, we employ the same
   naming conventions as explained at <code><a href="Effect-TH.html#v:defineEffectType" title="Effect.TH">defineEffectType</a></code>.</li></ul><ol><li value="2">the &quot;interpretation&quot; instance</li></ol><pre>instance (MonadFoo a b m) =&gt; InterpretEffect m (MonadFooEffect a b)</pre><p>says that for any <code>MonadFoo a b m</code>, we can interpret the effects described
 by <code>MonadFooEffect a b</code> into <code>m</code>.</p><p><em>remark for the general case</em>: This macro works by using the &quot;additional
 constraints&quot; arguments to <code><a href="Effect-TH.html#v:makeReification" title="Effect.TH">makeReification</a></code> and <code><a href="Effect-TH.html#v:makeInterpretation" title="Effect.TH">makeInterpretation</a></code>. If you
 want to generate the instances with other constraints, you'll have to use
 these two macros directly.</p></div></div><div class="top"><p class="src"><a id="v:makeReification" class="def">makeReification</a> <a href="src/Effect.TH.html#makeReification" class="link">Source</a> <a href="#v:makeReification" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: ([<a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>] -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Type" title="Language.Haskell.TH.Syntax">Type</a>)</td><td class="doc"><p>additional constraints for the instance head, depending on the names of
 extra type variables belonging to the effect type, and of <code>ops</code></p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a></td><td class="doc"><p>class name</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a></td><td class="doc"><p>the effect type</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>]</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Write a &quot;reification&quot; instance for an effect type. Such an instance
 allows writing <code><a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a></code>s containing effects of that type using the syntax of
 a class like <code>MonadError</code>, <code>MonadState</code>...</p><p>For example, given the effect type</p><pre>data ErrorEffect e m a where
  ThrowError :: e -&gt; ErrorEffect e m a
  CatchError :: m a -&gt; (e -&gt; m a) -&gt; ErrorEffect e m a</pre><p>the TH splice</p><pre>makeReification
  (\[e] ops -&gt; [t|SomeConstraint $(varT e) $(varT ops)|])
  ''MonadError
  ''ErrorEffect</pre><p>will expand into an instance like</p><pre>instance (SomeConstraint e ops, EffectInject (ErrorEffect e) ops) =&gt; MonadError e (AST ops) where
  throwError err = astInject (ThrowError err)
  catchError acts handler = astInject (CatchError acts handler)</pre><p>For this to work, it is expected that:</p><ul><li>The first quoted type passed to the splice is the class that you want to
   use for your syntax. Its kind should be <code>(* -&gt; *) -&gt; Constraint</code></li><li>The second quoted type is the effect type.
   Its kind should be <code>(* -&gt; *) -&gt; * -&gt; *</code>.</li><li>The constructor names of the effect type are exactly the method names
   of the class, just beginning with an upper case letter.</li></ul></div></div><div class="top"><p class="src"><a id="v:makeInterpretation" class="def">makeInterpretation</a> <a href="src/Effect.TH.html#makeInterpretation" class="link">Source</a> <a href="#v:makeInterpretation" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: ([<a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a>] -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Type" title="Language.Haskell.TH.Syntax">Type</a>)</td><td class="doc"><p>additional constraints for the instance head, depending on the names of
 extra type variables belonging to the effect type, and of <code>m</code></p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a></td><td class="doc"><p>class name</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a></td><td class="doc"><p>effect type name</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#t:Dec" title="Language.Haskell.TH.Syntax">Dec</a>]</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Write an &quot;interpretation&quot; instance for an effect type. Such an instance
 allows one to evaluate <code><a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a></code>s using the effect type. (For example, using <code><a href="Effect-Internal.html#v:interpretAST" title="Effect.Internal">interpretAST</a></code>)</p><p>For example, given the effect type</p><pre>data ErrorEffect e m a where
  ThrowError :: e -&gt; ErrorEffect e m a
  CatchError :: m a -&gt; (e -&gt; m a) -&gt; ErrorEffect e m a</pre><p>the TH splice</p><pre>makeInterpretation (\[e] m -&gt; [t|SomeConstraint $(varT e) $(varT m)|]) [t|ErrorEffect $(varT (mkName &quot;e&quot;))|]</pre><p>will expand into an instance like</p><pre>instance (SomeConstraint e m, MonadError e m) =&gt; InterpretEffect m (ErrorEffect e) where
  interpretEffect _ (ThrowError err) = throwError @e err
  interpretEffect evalAST (CatchError acts handler) = catchError @e (evalAST acts) (evalAST . handler)</pre><p>For this to work, it is expected that:</p><ul><li>The first quoted type passed to the splice is the class of monads that yow
   want to interpret the effect into. Its kind should be <code>(* -&gt; *) -&gt;
   Constraint</code></li><li>The second quoted type is the effect type.
   Its kind should be <code>(* -&gt; *) -&gt; * -&gt; *</code>.</li><li>The constructor names of the effect type are exactly the method names
   of the class, just beginning with an upper case letter.</li><li>The arguments of constructors of the effect type only use <code>m</code> in
   positive positions. This is not a restriction of the TemplateHaskell, but a
   restriction of the library. You can only &quot;nest&quot; <code><a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a></code>s in positive position.</li><li>For now, the TemplateHaskell works only if the arguments of constructors
   of the effect type only use the following type constructors:</li><li>The name of the &quot;nesting&quot; monad (here, that's <code>m</code>) applied to some type</li><li>Function Types (i.e. <code>-&gt;</code>, or <code><a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#v:ArrowT" title="Language.Haskell.TH.Syntax">ArrowT</a></code> in TH)</li><li>List Types (i.e. <code><a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#v:ListT" title="Language.Haskell.TH.Syntax">ListT</a></code> in TH)</li><li><code>Maybe</code>, <code>Either</code>, or <code>(,)</code> applied to some type(s)</li><li><code>IO</code> applied to some type</li><li>Parenheses (i.e. <code><a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#v:ParensT" title="Language.Haskell.TH.Syntax">ParensT</a></code> in TH)</li><li>Type Variables (i.e. <code><a href="https://hackage.haskell.org/package/-/docs/Language-Haskell-TH-Syntax.html#v:VarT" title="Language.Haskell.TH.Syntax">VarT</a></code> in TH)</li><li>Type Constructors of types of kind <code>*</code></li></ul></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.1</p></div></body></html>