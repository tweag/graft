<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Examples.Ltl.Simple</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">graft-0.0.0</span><ul class="links" id="page-menu"><li><a href="src/Examples.Ltl.Simple.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Examples.Ltl.Simple</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Example domain specification</a></li><li><a href="#g:2">Using the effect system</a></li><li><a href="#g:3">Defining a type of single-step modifications</a></li><li><a href="#g:4">Using <a href="Logic-Ltl.html">Logic.Ltl</a> to deploy single-step modifications</a></li><li><a href="#g:5">A few examples</a><ul><li><a href="#g:6"><code>somewhere</code></a></li><li><a href="#g:7"><code>everywhere</code></a></li><li><a href="#g:8"><code>there</code></a></li><li><a href="#g:9">Custom <code>Ltl</code> formulas</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A simple, but complete, tutorial for  how to use <a href="Logic-Ltl.html">Logic.Ltl</a>. This does
 not cover</p><ul><li>using higher-order effects in the LTL setting, and</li><li>combining several different effects in one test scenario.</li></ul><p>If you're reading the Haddock documentation, consider reading the source,
 it'll make more sense.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="#t:MonadKeyValue">MonadKeyValue</a> m <span class="keyword">where</span><ul class="subs"><li><a href="#v:storeValue">storeValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; m ()</li><li><a href="#v:getValue">getValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></li><li><a href="#v:deleteValue">deleteValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; m ()</li></ul></li><li class="src short"><a href="#v:swapTrace">swapTrace</a> :: <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m =&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)</li><li class="src short"><a href="#v:deleteTrace">deleteTrace</a> :: <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m =&gt; m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:KeyValueError">KeyValueError</a> = <a href="#v:NoSuchKey">NoSuchKey</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:KeyValueT">KeyValueT</a> m = <a href="https://hackage.haskell.org/package/-/docs/Control-Monad-Except.html#t:ExceptT" title="Control.Monad.Except">ExceptT</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (<a href="https://hackage.haskell.org/package/-/docs/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> (<a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>) m)</li><li class="src short"><a href="#v:runKeyValueT">runKeyValueT</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> a, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)</li><li class="src short"><span class="keyword">data</span> <a href="#t:MonadKeyValueEffect">MonadKeyValueEffect</a> :: <a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a> <span class="keyword">where</span><ul class="subs"><li><a href="#v:StoreValue">StoreValue</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> m ()</li><li><a href="#v:GetValue">GetValue</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></li><li><a href="#v:DeleteValue">DeleteValue</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> m ()</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:KeyValueMod">KeyValueMod</a> = <a href="#v:KeyValueMod">KeyValueMod</a> {<ul class="subs"><li><a href="#v:noOverwrite">noOverwrite</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li><a href="#v:renameKey">renameKey</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a></li></ul>}</li><li class="src short"><a href="#v:renameKeys">renameKeys</a> :: (<a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>) -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a></li><li class="src short"><a href="#v:noStoreOverride">noStoreOverride</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a></li><li class="src short"><a href="#v:interpretAndRun">interpretAndRun</a> :: <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> '[<a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a>, <a href="Effect-Error.html#t:MonadErrorEffect" title="Effect.Error">MonadErrorEffect</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a>] a -&gt; [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> a, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleSomewhereSwap">exampleSomewhereSwap</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleSomewhereDelete">exampleSomewhereDelete</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleEverywhereSwap">exampleEverywhereSwap</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleEverywhereDelete">exampleEverywhereDelete</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleEverywhereEmpty">exampleEverywhereEmpty</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleThere">exampleThere</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleNotThere">exampleNotThere</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleCustom">exampleCustom</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Example domain specification</h1></a><div class="doc"><p>To use this library, you need a type class of monads that captures the
 behaviour you want to test. For the sake of this tutorial, let's take a
 key-value-store where the keys are <code><a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a></code>s and the values are <code><a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></code>s.</p></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a id="t:MonadKeyValue" class="def">MonadKeyValue</a> m <span class="keyword">where</span> <a href="src/Examples.Ltl.Simple.html#MonadKeyValue" class="link">Source</a> <a href="#t:MonadKeyValue" class="selflink">#</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:storeValue" class="def">storeValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; m () <a href="src/Examples.Ltl.Simple.html#storeValue" class="link">Source</a> <a href="#v:storeValue" class="selflink">#</a></p><p class="src"><a id="v:getValue" class="def">getValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Examples.Ltl.Simple.html#getValue" class="link">Source</a> <a href="#v:getValue" class="selflink">#</a></p><p class="src"><a id="v:deleteValue" class="def">deleteValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; m () <a href="src/Examples.Ltl.Simple.html#deleteValue" class="link">Source</a> <a href="#v:deleteValue" class="selflink">#</a></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:MonadKeyValue">Instances</h4><details id="i:MonadKeyValue" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadKeyValue:MonadKeyValue:1"></span> ((), <a href="Effect-Internal.html#t:EffectInject" title="Effect.Internal">EffectInject</a> <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> ops) =&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> (<a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops)</span> <a href="src/Examples.Ltl.Simple.html#line-138" class="link">Source</a> <a href="#t:MonadKeyValue" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:MonadKeyValue:MonadKeyValue:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:storeValue">storeValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops () <a href="src/Examples.Ltl.Simple.html#storeValue" class="link">Source</a> <a href="#v:storeValue" class="selflink">#</a></p><p class="src"><a href="#v:getValue">getValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Examples.Ltl.Simple.html#getValue" class="link">Source</a> <a href="#v:getValue" class="selflink">#</a></p><p class="src"><a href="#v:deleteValue">deleteValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops () <a href="src/Examples.Ltl.Simple.html#deleteValue" class="link">Source</a> <a href="#v:deleteValue" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadKeyValue:MonadKeyValue:2"></span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> (<a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m)</span> <a href="src/Examples.Ltl.Simple.html#line-89" class="link">Source</a> <a href="#t:MonadKeyValue" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:MonadKeyValue:MonadKeyValue:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:storeValue">storeValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m () <a href="src/Examples.Ltl.Simple.html#storeValue" class="link">Source</a> <a href="#v:storeValue" class="selflink">#</a></p><p class="src"><a href="#v:getValue">getValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Examples.Ltl.Simple.html#getValue" class="link">Source</a> <a href="#v:getValue" class="selflink">#</a></p><p class="src"><a href="#v:deleteValue">deleteValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m () <a href="src/Examples.Ltl.Simple.html#deleteValue" class="link">Source</a> <a href="#v:deleteValue" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="doc"><p>We'll assume a number of <em>traces</em> written using this type class. These will
 most likely be manually written test cases that cover (some part of) the
 normal usage of the system you're testing.</p><p>Here, we'll only write two slightly silly examples. The more different
 scenarios you cover in these &quot;seed&quot; traces, the more interesting variations
 will be generated later on.</p></div><div class="top"><p class="src"><a id="v:swapTrace" class="def">swapTrace</a> :: <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m =&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>) <a href="src/Examples.Ltl.Simple.html#swapTrace" class="link">Source</a> <a href="#v:swapTrace" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:deleteTrace" class="def">deleteTrace</a> :: <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m =&gt; m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Examples.Ltl.Simple.html#deleteTrace" class="link">Source</a> <a href="#v:deleteTrace" class="selflink">#</a></p></div><div class="doc"><p>What we'll test is an implementation of <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>. We'll
 implement it very simply, but note that the implementation of
 <code><a href="Examples-Ltl-Simple.html#v:deleteValue" title="Examples.Ltl.Simple">deleteValue</a></code> is wrong: we never delete anything from the
 store. We'll &quot;find&quot; this mistake later on.</p></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a id="t:KeyValueError" class="def">KeyValueError</a> <a href="src/Examples.Ltl.Simple.html#KeyValueError" class="link">Source</a> <a href="#t:KeyValueError" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:NoSuchKey" class="def">NoSuchKey</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:KeyValueError">Instances</h4><details id="i:KeyValueError" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueError:Show:1"></span> <a href="https://hackage.haskell.org/package/-/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a></span> <a href="src/Examples.Ltl.Simple.html#line-82" class="link">Source</a> <a href="#t:KeyValueError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueError:Show:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a>] -&gt; <a href="https://hackage.haskell.org/package/-/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueError:Alternative:2"></span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m =&gt; <a href="https://hackage.haskell.org/package/-/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> (<a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m)</span> <a href="src/Examples.Ltl.Simple.html#line-285" class="link">Source</a> <a href="#t:KeyValueError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueError:Alternative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:empty">empty</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a <a href="#v:empty" class="selflink">#</a></p><p class="src"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a <a href="#v:-60--124--62-" class="selflink">#</a></p><p class="src"><a href="#v:some">some</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m [a] <a href="#v:some" class="selflink">#</a></p><p class="src"><a href="#v:many">many</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m [a] <a href="#v:many" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueError:MonadPlus:3"></span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m =&gt; <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> (<a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m)</span> <a href="src/Examples.Ltl.Simple.html#line-289" class="link">Source</a> <a href="#t:KeyValueError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueError:MonadPlus:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mzero">mzero</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a <a href="#v:mzero" class="selflink">#</a></p><p class="src"><a href="#v:mplus">mplus</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a <a href="#v:mplus" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueError:MonadKeyValue:4"></span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> (<a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m)</span> <a href="src/Examples.Ltl.Simple.html#line-89" class="link">Source</a> <a href="#t:KeyValueError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueError:MonadKeyValue:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:storeValue">storeValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m () <a href="src/Examples.Ltl.Simple.html#storeValue" class="link">Source</a> <a href="#v:storeValue" class="selflink">#</a></p><p class="src"><a href="#v:getValue">getValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Examples.Ltl.Simple.html#getValue" class="link">Source</a> <a href="#v:getValue" class="selflink">#</a></p><p class="src"><a href="#v:deleteValue">deleteValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m () <a href="src/Examples.Ltl.Simple.html#deleteValue" class="link">Source</a> <a href="#v:deleteValue" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:KeyValueT" class="def">KeyValueT</a> m = <a href="https://hackage.haskell.org/package/-/docs/Control-Monad-Except.html#t:ExceptT" title="Control.Monad.Except">ExceptT</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (<a href="https://hackage.haskell.org/package/-/docs/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> (<a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>) m) <a href="src/Examples.Ltl.Simple.html#KeyValueT" class="link">Source</a> <a href="#t:KeyValueT" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:runKeyValueT" class="def">runKeyValueT</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> a, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>) <a href="src/Examples.Ltl.Simple.html#runKeyValueT" class="link">Source</a> <a href="#v:runKeyValueT" class="selflink">#</a></p></div><a href="#g:2" id="g:2"><h1>Using the effect system</h1></a><div class="doc"><p>This library is based on a custom effect system. There are a few macros that
 will make using it more convenient. You'll at least need the following
 language extensions (more extensions might be needed in more complex
 scenarios than this tutorial):</p><pre>{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}</pre><p>The first macro will write an <em>effect type</em> corresponding to <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>
 for us, and give it the name <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code>:</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:MonadKeyValueEffect" class="def">MonadKeyValueEffect</a> :: <a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a> <span class="keyword">where</span> <a href="src/Examples.Ltl.Simple.html#MonadKeyValueEffect" class="link">Source</a> <a href="#t:MonadKeyValueEffect" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:StoreValue" class="def">StoreValue</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> m ()</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:GetValue" class="def">GetValue</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:DeleteValue" class="def">DeleteValue</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> m ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:MonadKeyValueEffect">Instances</h4><details id="i:MonadKeyValueEffect" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:MonadKeyValueEffect:InterpretEffect:1"></span> ((), <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m) =&gt; <a href="Effect-Internal.html#t:InterpretEffect" title="Effect.Internal">InterpretEffect</a> m <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></span> <a href="src/Examples.Ltl.Simple.html#line-138" class="link">Source</a> <a href="#t:MonadKeyValueEffect" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:MonadKeyValueEffect:InterpretEffect:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretEffect">interpretEffect</a> :: <span class="keyword">forall</span> (ops :: [<a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a>]) a. (<span class="keyword">forall</span> b. <a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops b -&gt; m b) -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> (<a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops) a -&gt; m a <a href="src/Effect.Internal.html#interpretEffect" class="link">Source</a> <a href="#v:interpretEffect" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:MonadKeyValueEffect:InterpretMod:2"></span> (<a href="https://hackage.haskell.org/package/-/docs/Control-Monad-Error-Class.html#t:MonadError" title="Control.Monad.Error.Class">MonadError</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> m, <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m) =&gt; <a href="Logic-SingleStep.html#t:InterpretMod" title="Logic.SingleStep">InterpretMod</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> m <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></span> <a href="src/Examples.Ltl.Simple.html#line-192" class="link">Source</a> <a href="#t:MonadKeyValueEffect" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:MonadKeyValueEffect:InterpretMod:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretMod">interpretMod</a> :: <span class="keyword">forall</span> (dummy :: [<a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a>]) a. <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> (<a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> dummy) a -&gt; <a href="Logic-SingleStep.html#t:ModInterp" title="Logic.SingleStep">ModInterp</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> m a <a href="src/Logic.SingleStep.html#interpretMod" class="link">Source</a> <a href="#v:interpretMod" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="doc"><p>The type <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code> is an abstract representation of the class
 <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>. This means that for each method of the class, there's a
 constructor of the effect type:</p><ul><li>for <code>storeValue :: String -&gt; Integer -&gt; m ()</code>, there is <code>StoreValue :: String -&gt; Integer -&gt; MonadKeyValueEffect m ()</code>,</li><li>for <code>getValue :: String -&gt; m Integer</code>, there is <code>GetValue :: String -&gt; MonadKeyValueEffect m Integer</code>, and</li><li>for <code>deleteValue :: String -&gt; m ()</code>, there is <code>DeleteValue :: String -&gt; MonadKeyValueEffect m ()</code>.</li></ul><p>We thus have a reification of computations in <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>. This
 reification will be used to build <code>AST</code>s, which can then be interpreted in
 flexible ways.</p><p>There's also a macro to define some instances that will make this
 convenient.</p></div><a href="#g:3" id="g:3"><h1>Defining a type of single-step modifications</h1></a><div class="doc"><p>The testing method explained in this tutorial consists in deploying
 single-step modifications while interpreting an <code>AST</code>. The <code>AST</code> will be
 built from abstract representations of actions (i.e. the constructors of
 effect types like <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code>), and we'll interpret it into some
 suitable monad (here, that'll be <code>KeyValueT m</code>).</p><p>So, we'll first have to define a type of single-step modifications, and
 explain how they should change the interpretation of actions. The
 single-step modifications have no meaning in and of them themselves, as they
 are only explained by how they apply to the constructors of
 <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code>.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:KeyValueMod" class="def">KeyValueMod</a> <a href="src/Examples.Ltl.Simple.html#KeyValueMod" class="link">Source</a> <a href="#t:KeyValueMod" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:KeyValueMod" class="def">KeyValueMod</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:noOverwrite" class="def">noOverwrite</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:renameKey" class="def">renameKey</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a></dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:KeyValueMod">Instances</h4><details id="i:KeyValueMod" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueMod:Semigroup:1"></span> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a></span> <a href="src/Examples.Ltl.Simple.html#line-234" class="link">Source</a> <a href="#t:KeyValueMod" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueMod:Semigroup:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueMod:InterpretMod:2"></span> (<a href="https://hackage.haskell.org/package/-/docs/Control-Monad-Error-Class.html#t:MonadError" title="Control.Monad.Error.Class">MonadError</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> m, <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m) =&gt; <a href="Logic-SingleStep.html#t:InterpretMod" title="Logic.SingleStep">InterpretMod</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> m <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></span> <a href="src/Examples.Ltl.Simple.html#line-192" class="link">Source</a> <a href="#t:KeyValueMod" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueMod:InterpretMod:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretMod">interpretMod</a> :: <span class="keyword">forall</span> (dummy :: [<a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a>]) a. <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> (<a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> dummy) a -&gt; <a href="Logic-SingleStep.html#t:ModInterp" title="Logic.SingleStep">ModInterp</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> m a <a href="src/Logic.SingleStep.html#interpretMod" class="link">Source</a> <a href="#v:interpretMod" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="doc"><p>Our modification type <code><a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a></code> captures two behaviours:</p><ul><li>When <code><a href="Examples-Ltl-Simple.html#v:noOverwrite" title="Examples.Ltl.Simple">noOverwrite</a></code> is <code>True</code>, the intended meaning is that
   <code><a href="Examples-Ltl-Simple.html#v:storeValue" title="Examples.Ltl.Simple">storeValue</a></code> should be ignored when it replaces the value (i.e., when the
   key is already present in the store)</li><li><code><a href="Examples-Ltl-Simple.html#v:renameKey" title="Examples.Ltl.Simple">renameKey</a></code> will change the keys used by any action with a prescribed
   function.</li></ul><p>The <code><a href="Logic-SingleStep.html#t:InterpretMod" title="Logic.SingleStep">InterpretMod</a></code> instance now makes these intended meanings explicit. The
 function <code><a href="Logic-SingleStep.html#v:interpretMod" title="Logic.SingleStep">interpretMod</a></code> describes, for each constructor of
 <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code>, how it should be interpreted under a modification:</p><ul><li>Whenever the there's a modification that might apply, we'll try to apply
   it using the <code>AttemptModification</code> constructor.</li><li>When the modification applies, we signal that success by wrapping the
     return value of the action in a <code><a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code>.</li><li>When the modification doesn't apply, we return <code><a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</li><li>Whenever there's no modification, we have nothing to apply, so we return
   <code>SkipModification</code>. This will mean that the operation will be performed as
   usual.</li><li>A third possibility, which is not shown here, is returning <code>PassModification</code>
   instead of <code>AttemptModification</code> or <code>SkipModification</code>, which would mean
   to do the operation without modification as usual, but remember the
   modification for the next step. This can be thought of as making the
   operation invisible to modifications.</li></ul></div><div class="doc"><p>Here are two smart constructors for modifications, one for creating a
 modification that transforms keys solely, the other that only ignores
 overwrites:</p></div><div class="top"><p class="src"><a id="v:renameKeys" class="def">renameKeys</a> :: (<a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>) -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> <a href="src/Examples.Ltl.Simple.html#renameKeys" class="link">Source</a> <a href="#v:renameKeys" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:noStoreOverride" class="def">noStoreOverride</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> <a href="src/Examples.Ltl.Simple.html#noStoreOverride" class="link">Source</a> <a href="#v:noStoreOverride" class="selflink">#</a></p></div><a href="#g:4" id="g:4"><h1>Using <a href="Logic-Ltl.html">Logic.Ltl</a> to deploy single-step modifications</h1></a><div class="doc"><p>The module <a href="Logic-Ltl.html">Logic.Ltl</a> implements one way to combine single-step
 modifications into composite modifications that apply to traces: a formula
 in an LTL-like language determines when to apply the single-step
 modifications.</p><p>The evaluation of such <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formulas sometimes makes it necessary to try
 applying two single-step modifications on the same step. The <code><a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a></code>
 instance describes how they should combine.</p></div><div class="doc"><p>The module <a href="Logic-Ltl.html">Logic.Ltl</a> provides the wrapper type <code><code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code> mod ops</code>.
 Here, <code>ops</code> is the list of effect types related to our domain. In our case,
 it will have to contain <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code> and <code>MonadErrorEffect
 KeyValueError</code>. The Template Haskell macros we used above make it so that</p><pre>LtlAST mod '[MonadKeyValueEffect, MonadErrorEffect KeyValueError]</pre><p>is an instance of <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code> and <code>MonadError KeyValueError</code>. The
 parameter <code>mod</code> is the type of single-step modifications; here it is
 <code><a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a></code>.</p><p>In addition to all the <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code> and <code><a href="https://hackage.haskell.org/package/-/docs/Control-Monad-Error-Class.html#t:MonadError" title="Control.Monad.Error.Class">MonadError</a></code> functions, the
 <code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code> also gives you access to the function</p><pre>modifyLtl :: Ltl mod -&gt; LtlAST mod ops a -&gt; LtlAST mod ops a</pre><p>This is what makes it possible to deploy composite <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> modifications: wrap
 the part of the computation you want to modify in <code><a href="Logic-Ltl.html#v:modifyLtl" title="Logic.Ltl">modifyLtl</a></code> with the <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code>
 formula of your choice.</p><p>The module <a href="Logic-Ltl.html">Logic.Ltl</a> also provides</p><pre>interpretLtlAST :: forall mod m ops a. (Semigroup mod, MonadPlus m, InterpretEffectsLtl mod m tags ops) =&gt; LtlAST mod ops a -&gt; m a</pre><p>which interprets the <code><code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code> mod ops</code> into any suitable monad <code>m</code>. Here,
 &quot;suitable&quot; means:</p><ul><li><p>All of the effects in <code>ops</code> have one of the following three instances:</p><ul><li><code>InterpretMod mod m</code> (this is what we have here)</li><li><code>InterpretLtlHigherOrder mod m</code> (this is for higher order effect
  types, we're not interested in that here)</li><li><code>InterpretEffectStateful (Const [Ltl mod]) m</code> (this is a low-level
  class used to implement the LTL framework itself)</li></ul></li><li><code>m</code> is a <code><a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a></code>. This is necessary because there might be several
   ways to satisfy an <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formula. The whole point of using <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> do describe
   modifications of a single trace is to try <em>all</em> of the possible ways to
   apply the formula. Sometimes, this requires defining a custom <code><a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a></code>
   instance for the monad (or transformer) we're interested in.</li></ul></div><div class="doc"><p>Using <code><a href="Logic-Ltl.html#v:interpretLtlAST" title="Logic.Ltl">interpretLtlAST</a></code>, we can write a convenience function that will
 interpret an <code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code> of <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code>s and return the final return value
 and state of the store.</p><p>Note how we type-apply <code><a href="Logic-Ltl.html#v:interpretLtlAST" title="Logic.Ltl">interpretLtlAST</a></code> to a list of &quot;tags&quot; of kind
 <code><a href="Logic-Ltl.html#t:LtlInstanceKind" title="Logic.Ltl">LtlInstanceKind</a></code>: These tags specify, in order, which of the three
 instances described above we expect the effects to have.</p><p>The <code>InterpretEffectStateful</code> instance for <code><a href="Effect-Error.html#t:MonadErrorEffect" title="Effect.Error">MonadErrorEffect</a></code> is imported
 from <a href="Effect-Error-Passthrough.html">Effect.Error.Passthrough</a>, and is implemented in a generic way so as
 to ignore every modification: we only care about modifying <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>
 actions.</p></div><div class="top"><p class="src"><a id="v:interpretAndRun" class="def">interpretAndRun</a> :: <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> '[<a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a>, <a href="Effect-Error.html#t:MonadErrorEffect" title="Effect.Error">MonadErrorEffect</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a>] a -&gt; [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> a, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#interpretAndRun" class="link">Source</a> <a href="#v:interpretAndRun" class="selflink">#</a></p></div><a href="#g:5" id="g:5"><h1>A few examples</h1></a><a href="#g:6" id="g:6"><h2><code>somewhere</code></h2></a><div class="doc"><p>By far the most commonly used <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formula is <code><a href="Logic-Ltl.html#v:somewhere" title="Logic.Ltl">somewhere</a></code>.</p><p>In our first example, we try applying the modification <code><a href="Examples-Ltl-Simple.html#v:noStoreOverride" title="Examples.Ltl.Simple">noStoreOverride</a></code> to
 some action in the <code><a href="Examples-Ltl-Simple.html#v:swapTrace" title="Examples.Ltl.Simple">swapTrace</a></code>. There are two actions where the modification
 applies, namely the third and fourth <code><a href="Examples-Ltl-Simple.html#v:storeValue" title="Examples.Ltl.Simple">storeValue</a></code>s:</p><pre>swapTrace = do
  storeValue &quot;a&quot; 1
  storeValue &quot;b&quot; 2
  a &lt;- getValue &quot;a&quot;
  b &lt;- getValue &quot;b&quot;
  storeValue &quot;a&quot; b   -- replaced by no-op in branch 1
  storeValue &quot;b&quot; a   -- replaced by no-op in branch 2
  a' &lt;- getValue &quot;a&quot;
  b' &lt;- getValue &quot;b&quot;</pre><p>So, we expect to have two modified traces, where both &quot;a&quot; and &quot;b&quot; share the
 same value, and that's indeed the case:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleSomewhereSwap
</code></strong>[(Right (1,1),fromList [(&quot;a&quot;,1),(&quot;b&quot;,1)]),
 (Right (2,2),fromList [(&quot;a&quot;,2),(&quot;b&quot;,2)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleSomewhereSwap" class="def">exampleSomewhereSwap</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleSomewhereSwap" class="link">Source</a> <a href="#v:exampleSomewhereSwap" class="selflink">#</a></p></div><div class="doc"><p>In the <code><a href="Examples-Ltl-Simple.html#v:deleteTrace" title="Examples.Ltl.Simple">deleteTrace</a></code>, we expect <code><a href="Examples-Ltl-Simple.html#v:noStoreOverride" title="Examples.Ltl.Simple">noStoreOverride</a></code> never to apply as
 there should be no override. However, it applies because our
 implementation of <code>deleteKey</code> does not actually delete anything.</p><pre>deleteTrace = do
  storeValue &quot;a&quot; 1
  storeValue &quot;b&quot; 2
  deleteValue &quot;a&quot;
  storeValue &quot;a&quot; 2 -- replaced by no-op
  getValue &quot;a&quot;</pre><p>We have &quot;discovered&quot; the bug!</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleSomewhereDelete
</code></strong>[(Right 1,fromList [(&quot;a&quot;,1),(&quot;b&quot;,2)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleSomewhereDelete" class="def">exampleSomewhereDelete</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleSomewhereDelete" class="link">Source</a> <a href="#v:exampleSomewhereDelete" class="selflink">#</a></p></div><a href="#g:7" id="g:7"><h2><code>everywhere</code></h2></a><div class="doc"><p>Another very commonly used <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formula is <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code>. It must
 apply the given single-step modification to every action in the
 <code>AST</code>. If it is not applicable somewhere, then there will be no
 output trace.</p><p>So, when we apply <code>everywhere noStoreOverride</code> to the swapTrace, we'll get
 no results, because not all <code><a href="Examples-Ltl-Simple.html#v:storeValue" title="Examples.Ltl.Simple">storeValue</a></code>s in that trace replace the value at
 a key.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleEverywhereSwap
</code></strong>[]
</pre></div><div class="top"><p class="src"><a id="v:exampleEverywhereSwap" class="def">exampleEverywhereSwap</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleEverywhereSwap" class="link">Source</a> <a href="#v:exampleEverywhereSwap" class="selflink">#</a></p></div><div class="doc"><p>On the other hand, <code><a href="Examples-Ltl-Simple.html#v:renameKeys" title="Examples.Ltl.Simple">renameKeys</a></code> always applies, and hence we can
 successfully apply it to, say the <code><a href="Examples-Ltl-Simple.html#v:deleteTrace" title="Examples.Ltl.Simple">deleteTrace</a></code>, and thus prove that its
 behaviour is independent under renaming of keys.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleEverywhereDelete
</code></strong>[(Right 2,fromList [(&quot;anew&quot;,2),(&quot;bnew&quot;,2)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleEverywhereDelete" class="def">exampleEverywhereDelete</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleEverywhereDelete" class="link">Source</a> <a href="#v:exampleEverywhereDelete" class="selflink">#</a></p></div><div class="doc"><p>Note that, unlike <code><a href="Logic-Ltl.html#v:somewhere" title="Logic.Ltl">somewhere</a></code>, <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code> doesn't imply that any
 modification is applied. Applying <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code> to an empty trace is
 successful, and returns one result:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleEverywhereEmpty
</code></strong>[((),fromList [])]
</pre></div><div class="top"><p class="src"><a id="v:exampleEverywhereEmpty" class="def">exampleEverywhereEmpty</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleEverywhereEmpty" class="link">Source</a> <a href="#v:exampleEverywhereEmpty" class="selflink">#</a></p></div><a href="#g:8" id="g:8"><h2><code>there</code></h2></a><div class="doc"><p>In addition to <code><a href="Logic-Ltl.html#v:somewhere" title="Logic.Ltl">somewhere</a></code> and <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code>, it is also possible to
 require the application of a modification starting from a specific position in
 a trace using <code><a href="Logic-Ltl.html#v:there" title="Logic.Ltl">there</a></code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleThere
</code></strong>[(Right (),fromList [(&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;cnew&quot;,3),(&quot;d&quot;,4)]),
 (Right (),fromList [(&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;c&quot;,3),(&quot;dnew&quot;,4)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleThere" class="def">exampleThere</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleThere" class="link">Source</a> <a href="#v:exampleThere" class="selflink">#</a></p></div><div class="doc"><p>Another idiom to accomplish the same without using <code><a href="Logic-Ltl.html#v:there" title="Logic.Ltl">there</a></code> is to only apply
 <code><a href="Logic-Ltl.html#v:modifyLtl" title="Logic.Ltl">modifyLtl</a></code> after the first few actions:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleNotThere
</code></strong>[(Right (),fromList [(&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;cnew&quot;,3),(&quot;d&quot;,4)]),
 (Right (),fromList [(&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;c&quot;,3),(&quot;dnew&quot;,4)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleNotThere" class="def">exampleNotThere</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleNotThere" class="link">Source</a> <a href="#v:exampleNotThere" class="selflink">#</a></p></div><a href="#g:9" id="g:9"><h2>Custom <code>Ltl</code> formulas</h2></a><div class="doc"><p>Finally, it is possible to create formulas by hand using the <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code>
 constructors. In this example, we add &quot;new&quot; to the key of the two
 first instructions of @deleteTrace</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleCustom
</code></strong>[(Right (),fromList [(&quot;anew&quot;,1),(&quot;bnew&quot;,2),(&quot;c&quot;,3),(&quot;d&quot;,4)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleCustom" class="def">exampleCustom</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleCustom" class="link">Source</a> <a href="#v:exampleCustom" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.27.0</p></div></body></html>