<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Examples.Ltl.Simple</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">sine-nomine-0.0.0</span><ul class="links" id="page-menu"><li><a href="src/Examples.Ltl.Simple.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Examples.Ltl.Simple</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Example domain and implementation</a></li><li><a href="#g:2">Using the effect system</a></li><li><a href="#g:3">Defining a type of single-step modifications</a></li><li><a href="#g:4">Using <a href="Logic-Ltl.html">Logic.Ltl</a> to deploy single-step modifications</a></li><li><a href="#g:5">A few examples</a><ul><li><a href="#g:6"><code>somewhere</code></a></li><li><a href="#g:7"><code>everywhere</code></a></li><li><a href="#g:8"><code>there</code></a></li><li><a href="#g:9">Custom <code>Ltl</code> formulas</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A simple, but complete, tutorial for  how to use <a href="Logic-Ltl.html">Logic.Ltl</a>. This does
 not cover</p><ul><li>using higher-order effects in the LTL setting, and</li><li>combining several different effects in one test scenario.</li></ul><p>If you're reading the Haddock documentation, consider reading the source,
 it'll make more sense.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="#t:MonadKeyValue">MonadKeyValue</a> m <span class="keyword">where</span><ul class="subs"><li><a href="#v:storeValue">storeValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; m ()</li><li><a href="#v:getValue">getValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></li><li><a href="#v:deleteValue">deleteValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; m ()</li></ul></li><li class="src short"><a href="#v:swapTrace">swapTrace</a> :: <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m =&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)</li><li class="src short"><a href="#v:deleteTrace">deleteTrace</a> :: <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m =&gt; m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:KeyValueError">KeyValueError</a> = <a href="#v:NoSuchKey">NoSuchKey</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:KeyValueT">KeyValueT</a> m = <a href="https://hackage.haskell.org/package/-/docs/Control-Monad-Except.html#t:ExceptT" title="Control.Monad.Except">ExceptT</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (<a href="https://hackage.haskell.org/package/-/docs/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> (<a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>) m)</li><li class="src short"><a href="#v:runKeyValueT">runKeyValueT</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> a, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)</li><li class="src short"><span class="keyword">data</span> <a href="#t:MonadKeyValueEffect">MonadKeyValueEffect</a> :: <a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a> <span class="keyword">where</span><ul class="subs"><li><a href="#v:StoreValue">StoreValue</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> m ()</li><li><a href="#v:GetValue">GetValue</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></li><li><a href="#v:DeleteValue">DeleteValue</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> m ()</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:KeyValueMod">KeyValueMod</a> = <a href="#v:KeyValueMod">KeyValueMod</a> {<ul class="subs"><li><a href="#v:noOverwrite">noOverwrite</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li><a href="#v:renameKey">renameKey</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a></li></ul>}</li><li class="src short"><a href="#v:renameKeys">renameKeys</a> :: (<a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>) -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a></li><li class="src short"><a href="#v:noStoreOverride">noStoreOverride</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a></li><li class="src short"><a href="#v:interpretAndRun">interpretAndRun</a> :: <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> '[<a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a>, <a href="Effect-Error.html#t:MonadErrorEffect" title="Effect.Error">MonadErrorEffect</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a>] a -&gt; [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> a, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleSomewhereSwap">exampleSomewhereSwap</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleSomewhereDelete">exampleSomewhereDelete</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleEverywhereSwap">exampleEverywhereSwap</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleEverywhereDelete">exampleEverywhereDelete</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleEverywhereEmpty">exampleEverywhereEmpty</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleThere">exampleThere</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleNotThere">exampleNotThere</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li><li class="src short"><a href="#v:exampleCustom">exampleCustom</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)]</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Example domain and implementation</h1></a><div class="doc"><p>To use this library, you need a type class of monads that captures the
 behaviour you want to test. For the sake of this tutorial, let's take a
 key-value-store where the keys are <code><a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a></code>s and the values are <code><a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></code>s.</p></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a id="t:MonadKeyValue" class="def">MonadKeyValue</a> m <span class="keyword">where</span> <a href="src/Examples.Ltl.Simple.html#MonadKeyValue" class="link">Source</a> <a href="#t:MonadKeyValue" class="selflink">#</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:storeValue" class="def">storeValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; m () <a href="src/Examples.Ltl.Simple.html#storeValue" class="link">Source</a> <a href="#v:storeValue" class="selflink">#</a></p><p class="src"><a id="v:getValue" class="def">getValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Examples.Ltl.Simple.html#getValue" class="link">Source</a> <a href="#v:getValue" class="selflink">#</a></p><p class="src"><a id="v:deleteValue" class="def">deleteValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; m () <a href="src/Examples.Ltl.Simple.html#deleteValue" class="link">Source</a> <a href="#v:deleteValue" class="selflink">#</a></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:MonadKeyValue">Instances</h4><details id="i:MonadKeyValue" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadKeyValue:MonadKeyValue:1"></span> ((), <a href="Effect-Internal.html#t:EffectInject" title="Effect.Internal">EffectInject</a> <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> ops) =&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> (<a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops)</span> <a href="src/Examples.Ltl.Simple.html#line-137" class="link">Source</a> <a href="#t:MonadKeyValue" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:MonadKeyValue:MonadKeyValue:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:storeValue">storeValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops () <a href="src/Examples.Ltl.Simple.html#storeValue" class="link">Source</a> <a href="#v:storeValue" class="selflink">#</a></p><p class="src"><a href="#v:getValue">getValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Examples.Ltl.Simple.html#getValue" class="link">Source</a> <a href="#v:getValue" class="selflink">#</a></p><p class="src"><a href="#v:deleteValue">deleteValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops () <a href="src/Examples.Ltl.Simple.html#deleteValue" class="link">Source</a> <a href="#v:deleteValue" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadKeyValue:MonadKeyValue:2"></span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> (<a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m)</span> <a href="src/Examples.Ltl.Simple.html#line-88" class="link">Source</a> <a href="#t:MonadKeyValue" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:MonadKeyValue:MonadKeyValue:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:storeValue">storeValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m () <a href="src/Examples.Ltl.Simple.html#storeValue" class="link">Source</a> <a href="#v:storeValue" class="selflink">#</a></p><p class="src"><a href="#v:getValue">getValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Examples.Ltl.Simple.html#getValue" class="link">Source</a> <a href="#v:getValue" class="selflink">#</a></p><p class="src"><a href="#v:deleteValue">deleteValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m () <a href="src/Examples.Ltl.Simple.html#deleteValue" class="link">Source</a> <a href="#v:deleteValue" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="doc"><p>We'll assume a number of <em>traces</em> written using this type class. These will
 most likely be manually written test cases that cover (some part of) the
 normal usage of the system you're testing.</p><p>Here, we'll only write two slightly silly examples. The more different
 scenarios you cover in these &quot;seed&quot; traces, the more interesting variations
 will be generated later on.</p></div><div class="top"><p class="src"><a id="v:swapTrace" class="def">swapTrace</a> :: <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m =&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>) <a href="src/Examples.Ltl.Simple.html#swapTrace" class="link">Source</a> <a href="#v:swapTrace" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:deleteTrace" class="def">deleteTrace</a> :: <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m =&gt; m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Examples.Ltl.Simple.html#deleteTrace" class="link">Source</a> <a href="#v:deleteTrace" class="selflink">#</a></p></div><div class="doc"><p>What we'll test is an implementation of <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>. We'll
 implement it very simply, but note that the implementation of
 <code><a href="Examples-Ltl-Simple.html#v:deleteValue" title="Examples.Ltl.Simple">deleteValue</a></code> is wrong: we never delete anything from the
 store. We'll &quot;find&quot; this mistake later on.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:KeyValueError" class="def">KeyValueError</a> <a href="src/Examples.Ltl.Simple.html#KeyValueError" class="link">Source</a> <a href="#t:KeyValueError" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:NoSuchKey" class="def">NoSuchKey</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:KeyValueError">Instances</h4><details id="i:KeyValueError" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueError:Show:1"></span> <a href="https://hackage.haskell.org/package/-/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a></span> <a href="src/Examples.Ltl.Simple.html#line-81" class="link">Source</a> <a href="#t:KeyValueError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueError:Show:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a>] -&gt; <a href="https://hackage.haskell.org/package/-/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueError:Alternative:2"></span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m =&gt; <a href="https://hackage.haskell.org/package/-/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> (<a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m)</span> <a href="src/Examples.Ltl.Simple.html#line-273" class="link">Source</a> <a href="#t:KeyValueError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueError:Alternative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:empty">empty</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a <a href="#v:empty" class="selflink">#</a></p><p class="src"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a <a href="#v:-60--124--62-" class="selflink">#</a></p><p class="src"><a href="#v:some">some</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m [a] <a href="#v:some" class="selflink">#</a></p><p class="src"><a href="#v:many">many</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m [a] <a href="#v:many" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueError:MonadPlus:3"></span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m =&gt; <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> (<a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m)</span> <a href="src/Examples.Ltl.Simple.html#line-277" class="link">Source</a> <a href="#t:KeyValueError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueError:MonadPlus:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mzero">mzero</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a <a href="#v:mzero" class="selflink">#</a></p><p class="src"><a href="#v:mplus">mplus</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a <a href="#v:mplus" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueError:MonadKeyValue:4"></span> <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> (<a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m)</span> <a href="src/Examples.Ltl.Simple.html#line-88" class="link">Source</a> <a href="#t:KeyValueError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueError:MonadKeyValue:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:storeValue">storeValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m () <a href="src/Examples.Ltl.Simple.html#storeValue" class="link">Source</a> <a href="#v:storeValue" class="selflink">#</a></p><p class="src"><a href="#v:getValue">getValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Examples.Ltl.Simple.html#getValue" class="link">Source</a> <a href="#v:getValue" class="selflink">#</a></p><p class="src"><a href="#v:deleteValue">deleteValue</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m () <a href="src/Examples.Ltl.Simple.html#deleteValue" class="link">Source</a> <a href="#v:deleteValue" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:KeyValueT" class="def">KeyValueT</a> m = <a href="https://hackage.haskell.org/package/-/docs/Control-Monad-Except.html#t:ExceptT" title="Control.Monad.Except">ExceptT</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (<a href="https://hackage.haskell.org/package/-/docs/Control-Monad-State-Lazy.html#t:StateT" title="Control.Monad.State.Lazy">StateT</a> (<a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>) m) <a href="src/Examples.Ltl.Simple.html#KeyValueT" class="link">Source</a> <a href="#t:KeyValueT" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:runKeyValueT" class="def">runKeyValueT</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueT" title="Examples.Ltl.Simple">KeyValueT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> a, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>) <a href="src/Examples.Ltl.Simple.html#runKeyValueT" class="link">Source</a> <a href="#v:runKeyValueT" class="selflink">#</a></p></div><a href="#g:2" id="g:2"><h1>Using the effect system</h1></a><div class="doc"><p>This library is based on a custom effect system. There are a few macros that
 will make using it more convenient. You'll at least need the following
 language extensions (more extensions might be needed in more complex
 scenarios than this tutorial):</p><pre>{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}</pre><p>The first macro will write an <em>effect type</em> corresponding to <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>
 for us, and give it the name <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code>:</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:MonadKeyValueEffect" class="def">MonadKeyValueEffect</a> :: <a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a> <span class="keyword">where</span> <a href="src/Examples.Ltl.Simple.html#MonadKeyValueEffect" class="link">Source</a> <a href="#t:MonadKeyValueEffect" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:StoreValue" class="def">StoreValue</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> m ()</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:GetValue" class="def">GetValue</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> m <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:DeleteValue" class="def">DeleteValue</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> m ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:MonadKeyValueEffect">Instances</h4><details id="i:MonadKeyValueEffect" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:MonadKeyValueEffect:InterpretEffect:1"></span> ((), <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m) =&gt; <a href="Effect-Internal.html#t:InterpretEffect" title="Effect.Internal">InterpretEffect</a> m <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></span> <a href="src/Examples.Ltl.Simple.html#line-137" class="link">Source</a> <a href="#t:MonadKeyValueEffect" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:MonadKeyValueEffect:InterpretEffect:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretEffect">interpretEffect</a> :: <span class="keyword">forall</span> (ops :: [<a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a>]) a. (<span class="keyword">forall</span> b. <a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops b -&gt; m b) -&gt; <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> (<a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops) a -&gt; m a <a href="src/Effect.Internal.html#interpretEffect" class="link">Source</a> <a href="#v:interpretEffect" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:MonadKeyValueEffect:InterpretMod:2"></span> (<a href="https://hackage.haskell.org/package/-/docs/Control-Monad-Error-Class.html#t:MonadError" title="Control.Monad.Error.Class">MonadError</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> m, <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m) =&gt; <a href="Logic-SingleStep.html#t:InterpretMod" title="Logic.SingleStep">InterpretMod</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> m <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></span> <a href="src/Examples.Ltl.Simple.html#line-183" class="link">Source</a> <a href="#t:MonadKeyValueEffect" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:MonadKeyValueEffect:InterpretMod:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretMod">interpretMod</a> :: <span class="keyword">forall</span> (dummy :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> dummy a -&gt; <a href="Logic-SingleStep.html#t:ModInterp" title="Logic.SingleStep">ModInterp</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> m a <a href="src/Logic.SingleStep.html#interpretMod" class="link">Source</a> <a href="#v:interpretMod" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="doc"><p>The type <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code> is an abstract representation of the class
 <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>. This means that for each method of the class, there's a
 constructor of the effect type:</p><ul><li>for <code>storeValue :: String -&gt; Integer -&gt; m ()</code>, there is <code>StoreValue :: String -&gt; Integer -&gt; MonadKeyValueEffect m ()</code>,</li><li>for <code>getValue :: String -&gt; m Integer</code>, there is <code>GetValue :: String -&gt; MonadKeyValueEffect m Integer</code>, and</li><li>for <code>deleteValue :: String -&gt; m ()</code>, there is <code>DeleteValue :: String -&gt; MonadKeyValueEffect m ()</code>.</li></ul><p>We thus have a reification of computations in <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>. This
 reification will be used to build <code>AST</code>s, which can then be interpreted in
 flexible ways.</p><p>There's also a macro to define some instances that will make this
 convenient.</p></div><a href="#g:3" id="g:3"><h1>Defining a type of single-step modifications</h1></a><div class="doc"><p>The testing method explained in this tutorial consists in deploying
 single-step modifications while interpreting an <code>AST</code>. The <code>AST</code> will be
 built from abstract representations of actions (i.e. the constructors of
 effect types like <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code>), and we'll interpret it into some
 suitable monad (here, that'll be <code>KeyValueT m</code>).</p><p>So, we'll first have to define a type of single-step modifications, and
 explain how they should change the interpretation of actions. The
 single-step modifications have no meaning in and of them themselves, as they
 are only explained by how they apply to the constructors of
 <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code>.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:KeyValueMod" class="def">KeyValueMod</a> <a href="src/Examples.Ltl.Simple.html#KeyValueMod" class="link">Source</a> <a href="#t:KeyValueMod" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:KeyValueMod" class="def">KeyValueMod</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:noOverwrite" class="def">noOverwrite</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:renameKey" class="def">renameKey</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a></dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:KeyValueMod">Instances</h4><details id="i:KeyValueMod" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueMod:Semigroup:1"></span> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a></span> <a href="src/Examples.Ltl.Simple.html#line-222" class="link">Source</a> <a href="#t:KeyValueMod" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueMod:Semigroup:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:KeyValueMod:InterpretMod:2"></span> (<a href="https://hackage.haskell.org/package/-/docs/Control-Monad-Error-Class.html#t:MonadError" title="Control.Monad.Error.Class">MonadError</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> m, <a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a> m) =&gt; <a href="Logic-SingleStep.html#t:InterpretMod" title="Logic.SingleStep">InterpretMod</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> m <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></span> <a href="src/Examples.Ltl.Simple.html#line-183" class="link">Source</a> <a href="#t:KeyValueMod" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:KeyValueMod:InterpretMod:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretMod">interpretMod</a> :: <span class="keyword">forall</span> (dummy :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a> dummy a -&gt; <a href="Logic-SingleStep.html#t:ModInterp" title="Logic.SingleStep">ModInterp</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> m a <a href="src/Logic.SingleStep.html#interpretMod" class="link">Source</a> <a href="#v:interpretMod" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="doc"><p>Our modification type <code><a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a></code> captures two behaviours:</p><ul><li>When <code><a href="Examples-Ltl-Simple.html#v:noOverwrite" title="Examples.Ltl.Simple">noOverwrite</a></code> is <code>True</code>, the intended meaning is that
   <code><a href="Examples-Ltl-Simple.html#v:storeValue" title="Examples.Ltl.Simple">storeValue</a></code> should be ignored when it replaces the value (i.e., when the
   key is already present in the store)</li><li><code><a href="Examples-Ltl-Simple.html#v:renameKey" title="Examples.Ltl.Simple">renameKey</a></code> will change the keys used by any action with a prescribed
   function.</li></ul><p>The <code><a href="Logic-SingleStep.html#t:InterpretMod" title="Logic.SingleStep">InterpretMod</a></code> instance now makes these intended meanings explicit. The
 function <code><a href="Logic-SingleStep.html#v:interpretMod" title="Logic.SingleStep">interpretMod</a></code> describes, for each constructor of
 <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code>, how it should be interpreted:</p><ul><li>Whenever the modification applies, it signals that success by wrapping the
   return value of the action in a <code><a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code>.</li><li>Whenever the modification doesn't apply, it returns <code><a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</li><li>A third possibility, which is not shown here, is returning <code><a href="Logic-SingleStep.html#v:Ignore" title="Logic.SingleStep">Ignore</a></code> instead of
   <code><a href="Logic-SingleStep.html#v:Apply" title="Logic.SingleStep">Apply</a></code>, which would mean to skip the operation. This is neither a
   successfully applied modification, nor a failed application, and the
   modification will be applied at the next action in the <code>AST</code>.</li></ul></div><div class="doc"><p>Here are two smart constructors for modifications, one for creating a
 modification that transforms keys solely, the other that only ignores
 overwrites:</p></div><div class="top"><p class="src"><a id="v:renameKeys" class="def">renameKeys</a> :: (<a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a>) -&gt; <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> <a href="src/Examples.Ltl.Simple.html#renameKeys" class="link">Source</a> <a href="#v:renameKeys" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:noStoreOverride" class="def">noStoreOverride</a> :: <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> <a href="src/Examples.Ltl.Simple.html#noStoreOverride" class="link">Source</a> <a href="#v:noStoreOverride" class="selflink">#</a></p></div><a href="#g:4" id="g:4"><h1>Using <a href="Logic-Ltl.html">Logic.Ltl</a> to deploy single-step modifications</h1></a><div class="doc"><p>The module <a href="Logic-Ltl.html">Logic.Ltl</a> implements one way to combine single-step
 modifications into composite modifications that apply to traces: a formula
 in an LTL-like language determines when to apply the single-step
 modifications.</p><p>The evaluation of such <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formulas sometimes makes it necessary to try
 applying two single-step modifications on the same step. The <code><a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a></code>
 instance describes how they should combine.</p></div><div class="doc"><p>The module <a href="Logic-Ltl.html">Logic.Ltl</a> provides the wrapper type <code><code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code> mod ops</code>.
 Here, <code>ops</code> is the list of effect types related to our domain. In our case,
 it will have to contain <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code> and <code>MonadErrorEffect
 KeyValueError</code>. The Template Haskell macros we used above make it so that</p><pre>LtlAST mod '[MonadKeyValueEffect, MonadErrorEffect KeyValueError]</pre><p>is an instance of <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code> and <code>MonadError KeyValueError</code>. The
 parameter <code>mod</code> is the type of single-step modifications; here it is
 <code><a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a></code>.</p><p>In addition to all the <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code> and <code><a href="https://hackage.haskell.org/package/-/docs/Control-Monad-Error-Class.html#t:MonadError" title="Control.Monad.Error.Class">MonadError</a></code> functions, the
 <code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code> also gives you access to the function</p><pre>modifyLtl :: Ltl mod -&gt; LtlAST mod ops a -&gt; LtlAST mod ops a</pre><p>This is what makes it possible to deploy composite <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> modifications: wrap
 the part of the computation you want to modify in <code><a href="Logic-Ltl.html#v:modifyLtl" title="Logic.Ltl">modifyLtl</a></code> with the <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code>
 formula of your choice.</p><p>The module <a href="Logic-Ltl.html">Logic.Ltl</a> also provides</p><pre>interpretLtlAST :: forall mod m ops a. (Semigroup mod, MonadPlus m, InterpretEffectsLtl mod m tags ops) =&gt; LtlAST mod ops a -&gt; m a</pre><p>which interprets the <code><code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code> mod ops</code> into any suitable monad <code>m</code>. Here,
 &quot;suitable&quot; means:</p><ul><li><p>All of the effects in <code>ops</code> have one of the following three instances:</p><ul><li><code>InterpretMod mod m</code> (this is what we have here)</li><li><code>InterpretLtlHigherOrder mod m</code> (this is for higher order effect
  types, we're not interested in that here)</li><li><code>InterpretEffectStateful (Const [Ltl mod]) m</code> (this is a low-level
  class used to implement the LTL framework itself)</li></ul></li><li><code>m</code> is a <code><a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a></code>. This is necessary because there might be several
   ways to satisfy an <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formula. The whole point of using <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> do describe
   modifications of a single trace is to try <em>all</em> of the possible ways to
   apply the formula. Sometimes, this requires defining a custom <code><a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a></code>
   instance for the monad (or transformer) we're interested in.</li></ul></div><div class="doc"><p>Using <code><a href="Logic-Ltl.html#v:interpretLtlAST" title="Logic.Ltl">interpretLtlAST</a></code>, we can write a convenience function that will
 interpret an <code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code> of <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a></code>s and return the final return value
 and state of the store.</p><p>Note how we type-apply <code><a href="Logic-Ltl.html#v:interpretLtlAST" title="Logic.Ltl">interpretLtlAST</a></code> to a list of &quot;tags&quot; of kind
 <code><a href="Logic-Ltl.html#t:LtlInstanceKind" title="Logic.Ltl">LtlInstanceKind</a></code>: These tags specify, in order, which of the three
 instances described above we expect the effects to have.</p><p>The <code>InterpretEffectStateful</code> instance for <code><a href="Effect-Error.html#t:MonadErrorEffect" title="Effect.Error">MonadErrorEffect</a></code> is imported
 from <a href="Effect-Error-Passthrough.html">Effect.Error.Passthrough</a>, and is implemented in a generic way so as
 to ignore every modification: we only care about modifying <code><a href="Examples-Ltl-Simple.html#t:MonadKeyValue" title="Examples.Ltl.Simple">MonadKeyValue</a></code>
 actions.</p></div><div class="top"><p class="src"><a id="v:interpretAndRun" class="def">interpretAndRun</a> :: <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> <a href="Examples-Ltl-Simple.html#t:KeyValueMod" title="Examples.Ltl.Simple">KeyValueMod</a> '[<a href="Examples-Ltl-Simple.html#t:MonadKeyValueEffect" title="Examples.Ltl.Simple">MonadKeyValueEffect</a>, <a href="Effect-Error.html#t:MonadErrorEffect" title="Effect.Error">MonadErrorEffect</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a>] a -&gt; [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> a, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#interpretAndRun" class="link">Source</a> <a href="#v:interpretAndRun" class="selflink">#</a></p></div><a href="#g:5" id="g:5"><h1>A few examples</h1></a><a href="#g:6" id="g:6"><h2><code>somewhere</code></h2></a><div class="doc"><p>By far the most commonly used <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formula is <code><a href="Logic-Ltl.html#v:somewhere" title="Logic.Ltl">somewhere</a></code>.</p><p>In our first example, we try applying the modification <code><a href="Examples-Ltl-Simple.html#v:noStoreOverride" title="Examples.Ltl.Simple">noStoreOverride</a></code> to
 some action in the <code><a href="Examples-Ltl-Simple.html#v:swapTrace" title="Examples.Ltl.Simple">swapTrace</a></code>. There are two actions where the modification
 applies, namely the third and fourth <code><a href="Examples-Ltl-Simple.html#v:storeValue" title="Examples.Ltl.Simple">storeValue</a></code>s:</p><pre>swapTrace = do
  storeValue &quot;a&quot; 1
  storeValue &quot;b&quot; 2
  a &lt;- getValue &quot;a&quot;
  b &lt;- getValue &quot;b&quot;
  storeValue &quot;a&quot; b   -- replaced by no-op in branch 1
  storeValue &quot;b&quot; a   -- replaced by no-op in branch 2
  a' &lt;- getValue &quot;a&quot;
  b' &lt;- getValue &quot;b&quot;</pre><p>So, we expect to have two modified traces, where both &quot;a&quot; and &quot;b&quot; share the
 same value, and that's indeed the case:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleSomewhereSwap
</code></strong>[(Right (1,1),fromList [(&quot;a&quot;,1),(&quot;b&quot;,1)]),
 (Right (2,2),fromList [(&quot;a&quot;,2),(&quot;b&quot;,2)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleSomewhereSwap" class="def">exampleSomewhereSwap</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleSomewhereSwap" class="link">Source</a> <a href="#v:exampleSomewhereSwap" class="selflink">#</a></p></div><div class="doc"><p>In the <code><a href="Examples-Ltl-Simple.html#v:deleteTrace" title="Examples.Ltl.Simple">deleteTrace</a></code>, we expect <code><a href="Examples-Ltl-Simple.html#v:noStoreOverride" title="Examples.Ltl.Simple">noStoreOverride</a></code> never to apply as
 there should be no override. However, it applies because our
 implementation of <code>deleteKey</code> does not actually delete anything.</p><pre>deleteTrace = do
  storeValue &quot;a&quot; 1
  storeValue &quot;b&quot; 2
  deleteValue &quot;a&quot;
  storeValue &quot;a&quot; 2 -- replaced by no-op
  getValue &quot;a&quot;</pre><p>We have &quot;discovered&quot; the bug!</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleSomewhereDelete
</code></strong>[(Right 1,fromList [(&quot;a&quot;,1),(&quot;b&quot;,2)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleSomewhereDelete" class="def">exampleSomewhereDelete</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleSomewhereDelete" class="link">Source</a> <a href="#v:exampleSomewhereDelete" class="selflink">#</a></p></div><a href="#g:7" id="g:7"><h2><code>everywhere</code></h2></a><div class="doc"><p>Another very commonly used <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formula is <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code>. It must
 apply the given single-step modification to every action in the
 <code>AST</code>. If it is not applicable somewhere, then there will be no
 output trace.</p><p>So, when we apply <code>everywhere noStoreOverride</code> to the swapTrace, we'll get
 no results, because not all <code><a href="Examples-Ltl-Simple.html#v:storeValue" title="Examples.Ltl.Simple">storeValue</a></code>s in that trace replace the value at
 a key.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleEverywhereSwap
</code></strong>[]
</pre></div><div class="top"><p class="src"><a id="v:exampleEverywhereSwap" class="def">exampleEverywhereSwap</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleEverywhereSwap" class="link">Source</a> <a href="#v:exampleEverywhereSwap" class="selflink">#</a></p></div><div class="doc"><p>On the other hand, <code><a href="Examples-Ltl-Simple.html#v:renameKeys" title="Examples.Ltl.Simple">renameKeys</a></code> always applies, and hence we can
 successfully apply it to, say the <code><a href="Examples-Ltl-Simple.html#v:deleteTrace" title="Examples.Ltl.Simple">deleteTrace</a></code>, and thus prove that its
 behaviour is independent under renaming of keys.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleEverywhereDelete
</code></strong>[(Right 2,fromList [(&quot;anew&quot;,2),(&quot;bnew&quot;,2)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleEverywhereDelete" class="def">exampleEverywhereDelete</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>, <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleEverywhereDelete" class="link">Source</a> <a href="#v:exampleEverywhereDelete" class="selflink">#</a></p></div><div class="doc"><p>Note that, unlike <code><a href="Logic-Ltl.html#v:somewhere" title="Logic.Ltl">somewhere</a></code>, <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code> doesn't imply that any
 modification is applied. Applying <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code> to an empty trace is
 successful, and returns one result:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleEverywhereEmpty
</code></strong>[((),fromList [])]
</pre></div><div class="top"><p class="src"><a id="v:exampleEverywhereEmpty" class="def">exampleEverywhereEmpty</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleEverywhereEmpty" class="link">Source</a> <a href="#v:exampleEverywhereEmpty" class="selflink">#</a></p></div><a href="#g:8" id="g:8"><h2><code>there</code></h2></a><div class="doc"><p>In addition to <code><a href="Logic-Ltl.html#v:somewhere" title="Logic.Ltl">somewhere</a></code> and <code><a href="Logic-Ltl.html#v:everywhere" title="Logic.Ltl">everywhere</a></code>, it is also possible to
 require the application of a modification starting from a specific position in
 a trace using <code><a href="Logic-Ltl.html#v:there" title="Logic.Ltl">there</a></code></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleThere
</code></strong>[(Right (),fromList [(&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;cnew&quot;,3),(&quot;d&quot;,4)]),
 (Right (),fromList [(&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;c&quot;,3),(&quot;dnew&quot;,4)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleThere" class="def">exampleThere</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleThere" class="link">Source</a> <a href="#v:exampleThere" class="selflink">#</a></p></div><div class="doc"><p>Another idiom to accomplish the same without using <code><a href="Logic-Ltl.html#v:there" title="Logic.Ltl">there</a></code> is to only apply
 <code><a href="Logic-Ltl.html#v:modifyLtl" title="Logic.Ltl">modifyLtl</a></code> after the first few actions:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleNotThere
</code></strong>[(Right (),fromList [(&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;cnew&quot;,3),(&quot;d&quot;,4)]),
 (Right (),fromList [(&quot;a&quot;,1),(&quot;b&quot;,2),(&quot;c&quot;,3),(&quot;dnew&quot;,4)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleNotThere" class="def">exampleNotThere</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleNotThere" class="link">Source</a> <a href="#v:exampleNotThere" class="selflink">#</a></p></div><a href="#g:9" id="g:9"><h2>Custom <code>Ltl</code> formulas</h2></a><div class="doc"><p>Finally, it is possible to create formulas by hand using the <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code>
 constructors. In this example, we add &quot;new&quot; to the key of the two
 first instructions of @deleteTrace</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>exampleCustom
</code></strong>[(Right (),fromList [(&quot;anew&quot;,1),(&quot;bnew&quot;,2),(&quot;c&quot;,3),(&quot;d&quot;,4)])]
</pre></div><div class="top"><p class="src"><a id="v:exampleCustom" class="def">exampleCustom</a> :: [(<a href="https://hackage.haskell.org/package/-/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="Examples-Ltl-Simple.html#t:KeyValueError" title="Examples.Ltl.Simple">KeyValueError</a> (), <a href="https://hackage.haskell.org/package/-/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a>)] <a href="src/Examples.Ltl.Simple.html#exampleCustom" class="link">Source</a> <a href="#v:exampleCustom" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.27.0</p></div></body></html>