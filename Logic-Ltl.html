<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Logic.Ltl</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">graft-0.0.0</span><ul class="links" id="page-menu"><li><a href="src/Logic.Ltl.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Logic.Ltl</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1"><code>Ltl</code> formulas</a></li><li><a href="#g:2">Deploying <code>Ltl</code> formulas</a></li><li><a href="#g:3">Higher-order effects</a></li><li><a href="#g:4">Interpreting <code>Ltl</code> modifications</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Generate state-aware modifications of sequences of stateful actions. The
 approach is to use an LTL-inspired language to build <em>composite</em>
 modifications that apply <em>atomic</em> modifications to specific steps. Each
 atomic modification's applicability and parameters may depend on the state
 reached so far, and there will be zero or more possibilities to apply each
 composite modification.</p><p>The workflow is to</p><ul><li>write effect types for all actions that you want to apply atomic
   modifications to,</li><li>write an abstract type describing your atomic modifications, together with
   a <code><a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a></code> instance that describes how they combine,</li><li>write instances of <code>InterpretLtl</code> (or <code><a href="Logic-Ltl.html#t:InterpretLtlHigherOrder" title="Logic.Ltl">InterpretLtlHigherOrder</a></code> for
   higher-order effects) that explain how your atomic modifications apply to
   your effects,
 Last reply today at 4:00 PM</li><li>use <code><a href="Logic-Ltl.html#v:modifyLtl" title="Logic.Ltl">modifyLtl</a></code> to apply composite modifications to your trace, and</li><li>use <code><a href="Logic-Ltl.html#v:interpretLtlAST" title="Logic.Ltl">interpretLtlAST</a></code> to run all modified versions of your trace.</li></ul><p>The module <a href="Examples-Ltl-Simple.html">Examples.Ltl.Simple</a> contains a tutorial.</p><p>For historic context, this is a re-implementation of the <a href="LTL.html">LTL</a> module from
 cooked-validators. The version this is based upon is:
 <a href="https://github.com/tweag/cooked-validators/blob/a460c1718d8d21bada510d83b705b24b0f8d36e0/src/Cooked/Ltl.hs">https://github.com/tweag/cooked-validators/blob/a460c1718d8d21bada510d83b705b24b0f8d36e0/src/Cooked/Ltl.hs</a></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Ltl">Ltl</a> a<ul class="subs"><li>= <a href="#v:LtlTruth">LtlTruth</a></li><li>| <a href="#v:LtlFalsity">LtlFalsity</a></li><li>| <a href="#v:LtlAtom">LtlAtom</a> a</li><li>| <a href="#v:LtlOr">LtlOr</a> (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a) (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a)</li><li>| <a href="#v:LtlAnd">LtlAnd</a> (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a) (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a)</li><li>| <a href="#v:LtlNext">LtlNext</a> (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a)</li><li>| <a href="#v:LtlUntil">LtlUntil</a> (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a) (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a)</li><li>| <a href="#v:LtlRelease">LtlRelease</a> (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a) (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a)</li></ul></li><li class="src short"><a href="#v:somewhere">somewhere</a> :: a -&gt; <a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a</li><li class="src short"><a href="#v:everywhere">everywhere</a> :: a -&gt; <a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a</li><li class="src short"><a href="#v:there">there</a> :: <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a -&gt; <a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a</li><li class="src short"><span class="keyword">type</span> <a href="#t:LtlAST">LtlAST</a> mod ops = <a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> (LtlEffect mod ': ops)</li><li class="src short"><a href="#v:modifyLtl">modifyLtl</a> :: <a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod -&gt; <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> mod ops a -&gt; <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> mod ops a</li><li class="src short"><span class="keyword">class</span> <a href="#t:InterpretLtlHigherOrder">InterpretLtlHigherOrder</a> (mod :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (op :: <a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a>) <span class="keyword">where</span><ul class="subs"><li><a href="#v:interpretLtlHigherOrder">interpretLtlHigherOrder</a> :: op (<a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops) a -&gt; <a href="Logic-Ltl.html#t:LtlInterpHigherOrder" title="Logic.Ltl">LtlInterpHigherOrder</a> mod m ops a</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:LtlInterpHigherOrder">LtlInterpHigherOrder</a> (mod :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (ops :: [<a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a>]) (a :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span><ul class="subs"><li><a href="#v:Direct">Direct</a> :: <a href="Logic-SingleStep.html#t:ModInterp" title="Logic.SingleStep">ModInterp</a> mod m a -&gt; <a href="Logic-Ltl.html#t:LtlInterpHigherOrder" title="Logic.Ltl">LtlInterpHigherOrder</a> mod m ops a</li><li><a href="#v:Nested">Nested</a> :: ((<span class="keyword">forall</span> b. [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod] -&gt; <a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops b -&gt; m (b, [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod])) -&gt; [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod] -&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod]))) -&gt; <a href="Logic-Ltl.html#t:LtlInterpHigherOrder" title="Logic.Ltl">LtlInterpHigherOrder</a> mod m ops a</li></ul></li><li class="src short"><a href="#v:nowLaterList">nowLaterList</a> :: <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> a =&gt; [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a] -&gt; [(<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a, [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a])]</li><li class="src short"><a href="#v:nowLaterSplit">nowLaterSplit</a> :: (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> x, <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m) =&gt; m a -&gt; (x -&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)) -&gt; [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> x] -&gt; m (a, [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> x])</li><li class="src short"><span class="keyword">data</span> <a href="#t:LtlInstanceKind">LtlInstanceKind</a><ul class="subs"><li>= <a href="#v:InterpretModTag">InterpretModTag</a></li><li>| <a href="#v:InterpretLtlHigherOrderTag">InterpretLtlHigherOrderTag</a></li><li>| <a href="#v:InterpretEffectStatefulTag">InterpretEffectStatefulTag</a></li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:InterpretEffectsLtl">InterpretEffectsLtl</a> (mod :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (tags :: [<a href="Logic-Ltl.html#t:LtlInstanceKind" title="Logic.Ltl">LtlInstanceKind</a>]) (ops :: [<a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a>]) <span class="keyword">where</span><ul class="subs"><li><a href="#v:interpretEffectsLtl">interpretEffectsLtl</a> :: InterpretEffectsLtlConstraintList mod m tags ops</li></ul></li><li class="src short"><a href="#v:interpretLtlAST">interpretLtlAST</a> :: <span class="keyword">forall</span> tags mod m ops a. (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> mod, <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m, <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m tags ops) =&gt; <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> mod ops a -&gt; m a</li><li class="src short"><a href="#v:interpretLtlASTWithInitialFormulas">interpretLtlASTWithInitialFormulas</a> :: <span class="keyword">forall</span> tags mod m ops a. (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> mod, <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m, <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m tags ops) =&gt; [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod] -&gt; <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> mod ops a -&gt; m a</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1><code>Ltl</code> formulas</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Ltl" class="def">Ltl</a> a <a href="src/Logic.Ltl.html#Ltl" class="link">Source</a> <a href="#t:Ltl" class="selflink">#</a></p><div class="doc"><p>Type of &quot;LTL&quot; formulas. Think of <code>a</code> as a type of atomic
 &quot;modifications&quot;, then a value of type <code>Ltl a</code> describes a composite
 modification that describes where to apply these modifications.</p><p>Since it does not make (obvious) sense to talk of a negated modification or
 of one modification (possibly in the future) to imply another modification,
 implication and negation are absent.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:LtlTruth" class="def">LtlTruth</a></td><td class="doc"><p>The &quot;do nothing&quot; modification that is always applicable</p></td></tr><tr><td class="src"><a id="v:LtlFalsity" class="def">LtlFalsity</a></td><td class="doc"><p>The modification that never applies</p></td></tr><tr><td class="src"><a id="v:LtlAtom" class="def">LtlAtom</a> a</td><td class="doc"><p>The modification that applies a given atomic modification at the
 current step</p></td></tr><tr><td class="src"><a id="v:LtlOr" class="def">LtlOr</a> (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a) (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a)</td><td class="doc"><p>Branch into the &quot;timeline&quot; where the left modification is applied
 and the one where the right modification is applied. (In a sense, this
 is an exclusive or, as we do not introduce the branch where both
 modifications are applied.)</p></td></tr><tr><td class="src"><a id="v:LtlAnd" class="def">LtlAnd</a> (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a) (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a)</td><td class="doc"><p>Apply both the left and the right modification. Attention: The &quot;apply
 both&quot; operation for  atomic modifications of type <code>a</code> will be
 user-defined through a <code><code><a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a></code></code> instance. If that operation
 isn't commutative, this conjunction may also fail to be commutative.</p></td></tr><tr><td class="src"><a id="v:LtlNext" class="def">LtlNext</a> (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a)</td><td class="doc"><p>Apply the given modification at the next step.</p></td></tr><tr><td class="src"><a id="v:LtlUntil" class="def">LtlUntil</a> (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a) (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a)</td><td class="doc"><p>Apply the first modification at least until the second one begins to
 be applicable (and is applied), which must happen eventually. The
 formulas</p><pre>a `LtlUntil` b</pre><p>and</p><pre>b `LtlOr` (a `LtlAnd` LtlNext (a `LtlUntil` b))</pre><p>are equivalent.</p></td></tr><tr><td class="src"><a id="v:LtlRelease" class="def">LtlRelease</a> (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a) (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a)</td><td class="doc"><p>Apply the second modification up to and including the step when the
 first one becomes applicable (and is applied); if that never happens,
 the second formula will be applied forever. View this as a dual to
 <code><a href="Logic-Ltl.html#v:LtlUntil" title="Logic.Ltl">LtlUntil</a></code>. The formulas</p><pre>a `LtlRelease` b</pre><p>and</p><pre>b `LtlAnd` (a `LtlOr` LtlNext (a `LtlRelease` b))</pre><p>are equivalent.</p></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Ltl">Instances</h4><details id="i:Ltl" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Ltl:Show:1"></span> <a href="https://hackage.haskell.org/package/-/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> a =&gt; <a href="https://hackage.haskell.org/package/-/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a)</span> <a href="src/Logic.Ltl.html#line-131" class="link">Source</a> <a href="#t:Ltl" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Ltl:Show:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Logic-Ltl.html">Logic.Ltl</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/-/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a -&gt; <a href="https://hackage.haskell.org/package/-/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a] -&gt; <a href="https://hackage.haskell.org/package/-/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:somewhere" class="def">somewhere</a> :: a -&gt; <a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a <a href="src/Logic.Ltl.html#somewhere" class="link">Source</a> <a href="#v:somewhere" class="selflink">#</a></p><div class="doc"><p>Apply an atomic modification to some action.</p></div></div><div class="top"><p class="src"><a id="v:everywhere" class="def">everywhere</a> :: a -&gt; <a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a <a href="src/Logic.Ltl.html#everywhere" class="link">Source</a> <a href="#v:everywhere" class="selflink">#</a></p><div class="doc"><p>Apply an atomic modification to all actions.</p></div></div><div class="top"><p class="src"><a id="v:there" class="def">there</a> :: <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a -&gt; <a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a <a href="src/Logic.Ltl.html#there" class="link">Source</a> <a href="#v:there" class="selflink">#</a></p><div class="doc"><p>Apply a modification from the n-th step in the trace (0-indexed).</p></div></div><a href="#g:2" id="g:2"><h1>Deploying <code>Ltl</code> formulas</h1></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:LtlAST" class="def">LtlAST</a> mod ops = <a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> (LtlEffect mod ': ops) <a href="src/Logic.Ltl.html#LtlAST" class="link">Source</a> <a href="#t:LtlAST" class="selflink">#</a></p><div class="doc"><p>An <code><a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a></code> that allows modifying parts of its contents with <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code>
 modifications, using <code><a href="Logic-Ltl.html#v:modifyLtl" title="Logic.Ltl">modifyLtl</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:modifyLtl" class="def">modifyLtl</a> :: <a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod -&gt; <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> mod ops a -&gt; <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> mod ops a <a href="src/Logic.Ltl.html#modifyLtl" class="link">Source</a> <a href="#v:modifyLtl" class="selflink">#</a></p><div class="doc"><p>Apply an <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> modification to an <code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code>. Think of <code>modifyLtl x acts</code> as
 &quot;try all ways to apply <code>x</code> to the actions given in <code>acts</code>&quot;.</p></div></div><a href="#g:3" id="g:3"><h1>Higher-order effects</h1></a><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:InterpretLtlHigherOrder" class="def">InterpretLtlHigherOrder</a> (mod :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (op :: <a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a>) <span class="keyword">where</span> <a href="src/Logic.Ltl.html#InterpretLtlHigherOrder" class="link">Source</a> <a href="#t:InterpretLtlHigherOrder" class="selflink">#</a></p><div class="doc"><p>Explain how to interpret an <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> modification, in the presence of
 higher-order effects. The type parameters have the same meaning as for
 <code>InterpretLtl</code>.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:interpretLtlHigherOrder" class="def">interpretLtlHigherOrder</a> :: op (<a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops) a -&gt; <a href="Logic-Ltl.html#t:LtlInterpHigherOrder" title="Logic.Ltl">LtlInterpHigherOrder</a> mod m ops a <a href="src/Logic.Ltl.html#interpretLtlHigherOrder" class="link">Source</a> <a href="#v:interpretLtlHigherOrder" class="selflink">#</a></p><div class="doc"><p>Given an operation of type <code>op a</code>, there are two possibilities,
 corresponding the two constructors of <code><a href="Logic-Ltl.html#t:LtlInterpHigherOrder" title="Logic.Ltl">LtlInterpHigherOrder</a></code>.</p><p>For simple operations that don't &quot;nest&quot; other <code><a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a></code>s, use the
 <code><a href="Logic-Ltl.html#v:Direct" title="Logic.Ltl">Direct</a></code> constructor. Its meaning corresponds precisely to the
 <code><a href="Logic-SingleStep.html#v:interpretMod" title="Logic.SingleStep">interpretMod</a></code> function.</p><p>For operations that <em>do</em> nest, use the <code><a href="Logic-Ltl.html#v:Nested" title="Logic.Ltl">Nested</a></code> constructor. It needs some
 explanation: the stepwise approach based on applying atomic modifications
 to single operations breaks down for higher-order operations, since a
 single higher-order operation may contain <code><a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a></code>s of operations. We'll
 likely want to use a composite modification while evaluating such nested
 <code><a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a></code>s.</p><p>Composite modifications in the current setting are lists of <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code>
 formulas, which are evaluated in parallel to the interpretation of the
 <code><a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a></code>. (Each <code><a href="Logic-Ltl.html#v:modifyLtl" title="Logic.Ltl">modifyLtl</a></code> adds another formula to the head of that list. If
 you don't nest <code><a href="Logic-Ltl.html#v:modifyLtl" title="Logic.Ltl">modifyLtl</a></code>s, the list will only ever contain one element.
 If you nest <code><a href="Logic-Ltl.html#v:modifyLtl" title="Logic.Ltl">modifyLtl</a></code>s, the head of the list will be the formula that
 was introduced by the innermost <code><a href="Logic-Ltl.html#v:modifyLtl" title="Logic.Ltl">modifyLtl</a></code>)</p><p>The <code><a href="Logic-Ltl.html#v:Nested" title="Logic.Ltl">Nested</a></code> constructor proposes the following approach: It'll just give
 you a function</p><pre>evalAST :: forall b. [Ltl mod] -&gt; AST ops b -&gt; m (b, [Ltl mod])</pre><p>which you can call on the nested <code><a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a></code>s, which it'll evaluate with the
 list of <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formulas you provide. To explain it by example, let's use
 <code>ErrorEffect</code>:</p><pre>instance (MonadError e m) =&gt; InterpretLtlHigherOrder x m (MonadErrorEffect e) where
  interpretLtlHigherOrder (CatchError acts handler) =
    Nested $ \evalAST ltls -&gt;
      Just
        &lt;$&gt; catchError
          (evalAST ltls acts)
          ( \err -&gt;
              do
                (a, _) &lt;- evalAST [] $ handler err
                return (a, ltls)
          )
  interpretLtlHigherOrder (ThrowError err) = ...</pre><p>The equation for <code>CatchError</code> means that you'll interpret the body <code>acts</code>
 with the composite modification currently in place. If any error is
 thrown, you'll run the <code>handler</code>, without any modifications at all, and
 restore the original composite modification. There might be other ways to
 implement this nesting behaviour, depending on your use case, and the
 <code><a href="Logic-Ltl.html#v:Nested" title="Logic.Ltl">Nested</a></code> constructor should hopefully be general enough to accommodate
 most of them. In particular, you can also return <code><a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> from the
 <code><a href="Logic-Ltl.html#v:Nested" title="Logic.Ltl">Nested</a></code> constructor to signal that with the current composite modification,
 the operation can't be evaluated.</p></div></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:InterpretLtlHigherOrder">Instances</h4><details id="i:InterpretLtlHigherOrder" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:InterpretLtlHigherOrder:InterpretLtlHigherOrder:1"></span> (<a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m, <a href="https://hackage.haskell.org/package/-/docs/Control-Monad-Error-Class.html#t:MonadError" title="Control.Monad.Error.Class">MonadError</a> <a href="Examples-Ltl-HigherOrder.html#t:MiniLangError" title="Examples.Ltl.HigherOrder">MiniLangError</a> m, <a href="Examples-Ltl-HigherOrder.html#t:MonadMiniLang" title="Examples.Ltl.HigherOrder">MonadMiniLang</a> m) =&gt; <a href="Logic-Ltl.html#t:InterpretLtlHigherOrder" title="Logic.Ltl">InterpretLtlHigherOrder</a> <a href="Examples-Ltl-HigherOrder.html#t:MiniLangMod" title="Examples.Ltl.HigherOrder">MiniLangMod</a> m <a href="Examples-Ltl-HigherOrder.html#t:MonadMiniLangEffect" title="Examples.Ltl.HigherOrder">MonadMiniLangEffect</a></span> <a href="src/Examples.Ltl.HigherOrder.html#line-277" class="link">Source</a> <a href="#t:InterpretLtlHigherOrder" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:InterpretLtlHigherOrder:InterpretLtlHigherOrder:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Examples-Ltl-HigherOrder.html">Examples.Ltl.HigherOrder</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretLtlHigherOrder">interpretLtlHigherOrder</a> :: <span class="keyword">forall</span> (ops :: [<a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a>]) a. <a href="Examples-Ltl-HigherOrder.html#t:MonadMiniLangEffect" title="Examples.Ltl.HigherOrder">MonadMiniLangEffect</a> (<a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops) a -&gt; <a href="Logic-Ltl.html#t:LtlInterpHigherOrder" title="Logic.Ltl">LtlInterpHigherOrder</a> <a href="Examples-Ltl-HigherOrder.html#t:MiniLangMod" title="Examples.Ltl.HigherOrder">MiniLangMod</a> m ops a <a href="src/Logic.Ltl.html#interpretLtlHigherOrder" class="link">Source</a> <a href="#v:interpretLtlHigherOrder" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:LtlInterpHigherOrder" class="def">LtlInterpHigherOrder</a> (mod :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (ops :: [<a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a>]) (a :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span> <a href="src/Logic.Ltl.html#LtlInterpHigherOrder" class="link">Source</a> <a href="#t:LtlInterpHigherOrder" class="selflink">#</a></p><div class="doc"><p>codomain of <code><a href="Logic-Ltl.html#v:interpretLtlHigherOrder" title="Logic.Ltl">interpretLtlHigherOrder</a></code>. See the explanation there.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Direct" class="def">Direct</a> :: <a href="Logic-SingleStep.html#t:ModInterp" title="Logic.SingleStep">ModInterp</a> mod m a -&gt; <a href="Logic-Ltl.html#t:LtlInterpHigherOrder" title="Logic.Ltl">LtlInterpHigherOrder</a> mod m ops a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Nested" class="def">Nested</a> :: ((<span class="keyword">forall</span> b. [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod] -&gt; <a href="Effect-Internal.html#t:AST" title="Effect.Internal">AST</a> ops b -&gt; m (b, [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod])) -&gt; [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod] -&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod]))) -&gt; <a href="Logic-Ltl.html#t:LtlInterpHigherOrder" title="Logic.Ltl">LtlInterpHigherOrder</a> mod m ops a</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a id="v:nowLaterList" class="def">nowLaterList</a> :: <a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> a =&gt; [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a] -&gt; [(<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a, [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> a])] <a href="src/Logic.Ltl.html#nowLaterList" class="link">Source</a> <a href="#v:nowLaterList" class="selflink">#</a></p><div class="doc"><p>We're passing around a list of <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formulas from each time
 step to the next.</p><p>This function returns computes a list of <code>(doNow, doLater)</code> pairs, where</p><ul><li><code>doNow</code> is <code>Just</code> the modification to be applied to the current time step,
   or <code>Nothing</code>, if no modification needs to be applied, and</li><li><code>doLater</code> is again a list of <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formulas describing the composite modification that
   should be applied from the next time step onwards.</li></ul><p>The return value is a list because a formula might be satisfied in different
 ways. For example, the modification described by <code>a <code><a href="Logic-Ltl.html#v:LtlUntil" title="Logic.Ltl">LtlUntil</a></code> b</code> might be
 accomplished by applying the modification <code>b</code> right now, or by applying <code>a</code>
 right now and <code>a <code><a href="Logic-Ltl.html#v:LtlUntil" title="Logic.Ltl">LtlUntil</a></code> b</code> from the next step onwards; the returned list
 will contain these two options.</p><p>Atomic modifications of type <code>a</code> should form a <code><a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a></code>, where <code><a href="https://hackage.haskell.org/package/-/docs/Data-Monoid.html#v:-60--62-" title="Data.Monoid">&lt;&gt;</a></code> is
 the composition of modifications. We interpret <code>x &lt;&gt; y</code> as the modification
 that first applies <code>y</code> and then <code>x</code>. Attention: Since we use <code><a href="https://hackage.haskell.org/package/-/docs/Data-Monoid.html#v:-60--62-" title="Data.Monoid">&lt;&gt;</a></code> to define
 conjunction, if <code><a href="https://hackage.haskell.org/package/-/docs/Data-Monoid.html#v:-60--62-" title="Data.Monoid">&lt;&gt;</a></code> is not commutative, conjunction will also fail to be
 commutative!</p></div></div><div class="top"><p class="src"><a id="v:nowLaterSplit" class="def">nowLaterSplit</a> :: (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> x, <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m) =&gt; m a -&gt; (x -&gt; m (<a href="https://hackage.haskell.org/package/-/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)) -&gt; [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> x] -&gt; m (a, [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> x]) <a href="src/Logic.Ltl.html#nowLaterSplit" class="link">Source</a> <a href="#v:nowLaterSplit" class="selflink">#</a></p></div><a href="#g:4" id="g:4"><h1>Interpreting <code>Ltl</code> modifications</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:LtlInstanceKind" class="def">LtlInstanceKind</a> <a href="src/Logic.Ltl.html#LtlInstanceKind" class="link">Source</a> <a href="#t:LtlInstanceKind" class="selflink">#</a></p><div class="doc"><p>Used to signify which instance is to be used for a specific effect in the
 <code><a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a></code> class.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:InterpretModTag" class="def">InterpretModTag</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:InterpretLtlHigherOrderTag" class="def">InterpretLtlHigherOrderTag</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:InterpretEffectStatefulTag" class="def">InterpretEffectStatefulTag</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:LtlInstanceKind">Instances</h4><details id="i:LtlInstanceKind" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:LtlInstanceKind:InterpretEffectsLtl:1"></span> <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m ('[] :: [<a href="Logic-Ltl.html#t:LtlInstanceKind" title="Logic.Ltl">LtlInstanceKind</a>]) ('[] :: [<a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a>])</span> <a href="src/Logic.Ltl.html#line-274" class="link">Source</a> <a href="#t:LtlInstanceKind" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:LtlInstanceKind:InterpretEffectsLtl:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Logic-Ltl.html">Logic.Ltl</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretEffectsLtl">interpretEffectsLtl</a> :: InterpretEffectsLtlConstraintList mod m '[] '[] <a href="src/Logic.Ltl.html#interpretEffectsLtl" class="link">Source</a> <a href="#v:interpretEffectsLtl" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:LtlInstanceKind:InterpretEffectsLtl:2"></span> (<a href="Effect-Internal.html#t:InterpretEffectStateful" title="Effect.Internal">InterpretEffectStateful</a> (<a href="https://hackage.haskell.org/package/-/docs/Data-Functor-Const.html#t:Const" title="Data.Functor.Const">Const</a> [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod] :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) m op, <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m tags ops) =&gt; <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m ('<a href="Logic-Ltl.html#v:InterpretEffectStatefulTag" title="Logic.Ltl">InterpretEffectStatefulTag</a> ': tags) (op ': ops)</span> <a href="src/Logic.Ltl.html#line-283" class="link">Source</a> <a href="#t:LtlInstanceKind" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:LtlInstanceKind:InterpretEffectsLtl:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Logic-Ltl.html">Logic.Ltl</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretEffectsLtl">interpretEffectsLtl</a> :: InterpretEffectsLtlConstraintList mod m ('<a href="Logic-Ltl.html#v:InterpretEffectStatefulTag" title="Logic.Ltl">InterpretEffectStatefulTag</a> ': tags) (op ': ops) <a href="src/Logic.Ltl.html#interpretEffectsLtl" class="link">Source</a> <a href="#v:interpretEffectsLtl" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:LtlInstanceKind:InterpretEffectsLtl:3"></span> (<a href="Effect-Internal.html#t:InterpretEffect" title="Effect.Internal">InterpretEffect</a> m op, <a href="Logic-Ltl.html#t:InterpretLtlHigherOrder" title="Logic.Ltl">InterpretLtlHigherOrder</a> mod m op, <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m tags ops) =&gt; <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m ('<a href="Logic-Ltl.html#v:InterpretLtlHigherOrderTag" title="Logic.Ltl">InterpretLtlHigherOrderTag</a> ': tags) (op ': ops)</span> <a href="src/Logic.Ltl.html#line-280" class="link">Source</a> <a href="#t:LtlInstanceKind" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:LtlInstanceKind:InterpretEffectsLtl:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Logic-Ltl.html">Logic.Ltl</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretEffectsLtl">interpretEffectsLtl</a> :: InterpretEffectsLtlConstraintList mod m ('<a href="Logic-Ltl.html#v:InterpretLtlHigherOrderTag" title="Logic.Ltl">InterpretLtlHigherOrderTag</a> ': tags) (op ': ops) <a href="src/Logic.Ltl.html#interpretEffectsLtl" class="link">Source</a> <a href="#v:interpretEffectsLtl" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:LtlInstanceKind:InterpretEffectsLtl:4"></span> (<a href="Effect-Internal.html#t:InterpretEffect" title="Effect.Internal">InterpretEffect</a> m op, <a href="Logic-SingleStep.html#t:InterpretMod" title="Logic.SingleStep">InterpretMod</a> mod m op, <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m tags ops) =&gt; <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m ('<a href="Logic-Ltl.html#v:InterpretModTag" title="Logic.Ltl">InterpretModTag</a> ': tags) (op ': ops)</span> <a href="src/Logic.Ltl.html#line-277" class="link">Source</a> <a href="#t:LtlInstanceKind" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:LtlInstanceKind:InterpretEffectsLtl:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Logic-Ltl.html">Logic.Ltl</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretEffectsLtl">interpretEffectsLtl</a> :: InterpretEffectsLtlConstraintList mod m ('<a href="Logic-Ltl.html#v:InterpretModTag" title="Logic.Ltl">InterpretModTag</a> ': tags) (op ': ops) <a href="src/Logic.Ltl.html#interpretEffectsLtl" class="link">Source</a> <a href="#v:interpretEffectsLtl" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:InterpretEffectsLtl" class="def">InterpretEffectsLtl</a> (mod :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (tags :: [<a href="Logic-Ltl.html#t:LtlInstanceKind" title="Logic.Ltl">LtlInstanceKind</a>]) (ops :: [<a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a>]) <span class="keyword">where</span> <a href="src/Logic.Ltl.html#InterpretEffectsLtl" class="link">Source</a> <a href="#t:InterpretEffectsLtl" class="selflink">#</a></p><div class="doc"><p>The constraint used by <code>interpretLtlASt</code> and similar functions. See the documentation there.</p><p>Users of the library will <em>never</em> have to write instances of this class.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:interpretEffectsLtl" class="def">interpretEffectsLtl</a> :: InterpretEffectsLtlConstraintList mod m tags ops <a href="src/Logic.Ltl.html#interpretEffectsLtl" class="link">Source</a> <a href="#v:interpretEffectsLtl" class="selflink">#</a></p><div class="doc"><p>A witness of the constraint.</p></div></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:InterpretEffectsLtl">Instances</h4><details id="i:InterpretEffectsLtl" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:InterpretEffectsLtl:InterpretEffectsLtl:1"></span> <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m ('[] :: [<a href="Logic-Ltl.html#t:LtlInstanceKind" title="Logic.Ltl">LtlInstanceKind</a>]) ('[] :: [<a href="Effect-Internal.html#t:Effect" title="Effect.Internal">Effect</a>])</span> <a href="src/Logic.Ltl.html#line-274" class="link">Source</a> <a href="#t:InterpretEffectsLtl" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:InterpretEffectsLtl:InterpretEffectsLtl:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Logic-Ltl.html">Logic.Ltl</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretEffectsLtl">interpretEffectsLtl</a> :: InterpretEffectsLtlConstraintList mod m '[] '[] <a href="src/Logic.Ltl.html#interpretEffectsLtl" class="link">Source</a> <a href="#v:interpretEffectsLtl" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:InterpretEffectsLtl:InterpretEffectsLtl:2"></span> (<a href="Effect-Internal.html#t:InterpretEffectStateful" title="Effect.Internal">InterpretEffectStateful</a> (<a href="https://hackage.haskell.org/package/-/docs/Data-Functor-Const.html#t:Const" title="Data.Functor.Const">Const</a> [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod] :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) m op, <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m tags ops) =&gt; <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m ('<a href="Logic-Ltl.html#v:InterpretEffectStatefulTag" title="Logic.Ltl">InterpretEffectStatefulTag</a> ': tags) (op ': ops)</span> <a href="src/Logic.Ltl.html#line-283" class="link">Source</a> <a href="#t:InterpretEffectsLtl" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:InterpretEffectsLtl:InterpretEffectsLtl:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Logic-Ltl.html">Logic.Ltl</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretEffectsLtl">interpretEffectsLtl</a> :: InterpretEffectsLtlConstraintList mod m ('<a href="Logic-Ltl.html#v:InterpretEffectStatefulTag" title="Logic.Ltl">InterpretEffectStatefulTag</a> ': tags) (op ': ops) <a href="src/Logic.Ltl.html#interpretEffectsLtl" class="link">Source</a> <a href="#v:interpretEffectsLtl" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:InterpretEffectsLtl:InterpretEffectsLtl:3"></span> (<a href="Effect-Internal.html#t:InterpretEffect" title="Effect.Internal">InterpretEffect</a> m op, <a href="Logic-Ltl.html#t:InterpretLtlHigherOrder" title="Logic.Ltl">InterpretLtlHigherOrder</a> mod m op, <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m tags ops) =&gt; <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m ('<a href="Logic-Ltl.html#v:InterpretLtlHigherOrderTag" title="Logic.Ltl">InterpretLtlHigherOrderTag</a> ': tags) (op ': ops)</span> <a href="src/Logic.Ltl.html#line-280" class="link">Source</a> <a href="#t:InterpretEffectsLtl" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:InterpretEffectsLtl:InterpretEffectsLtl:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Logic-Ltl.html">Logic.Ltl</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretEffectsLtl">interpretEffectsLtl</a> :: InterpretEffectsLtlConstraintList mod m ('<a href="Logic-Ltl.html#v:InterpretLtlHigherOrderTag" title="Logic.Ltl">InterpretLtlHigherOrderTag</a> ': tags) (op ': ops) <a href="src/Logic.Ltl.html#interpretEffectsLtl" class="link">Source</a> <a href="#v:interpretEffectsLtl" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:InterpretEffectsLtl:InterpretEffectsLtl:4"></span> (<a href="Effect-Internal.html#t:InterpretEffect" title="Effect.Internal">InterpretEffect</a> m op, <a href="Logic-SingleStep.html#t:InterpretMod" title="Logic.SingleStep">InterpretMod</a> mod m op, <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m tags ops) =&gt; <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m ('<a href="Logic-Ltl.html#v:InterpretModTag" title="Logic.Ltl">InterpretModTag</a> ': tags) (op ': ops)</span> <a href="src/Logic.Ltl.html#line-277" class="link">Source</a> <a href="#t:InterpretEffectsLtl" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:InterpretEffectsLtl:InterpretEffectsLtl:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Logic-Ltl.html">Logic.Ltl</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:interpretEffectsLtl">interpretEffectsLtl</a> :: InterpretEffectsLtlConstraintList mod m ('<a href="Logic-Ltl.html#v:InterpretModTag" title="Logic.Ltl">InterpretModTag</a> ': tags) (op ': ops) <a href="src/Logic.Ltl.html#interpretEffectsLtl" class="link">Source</a> <a href="#v:interpretEffectsLtl" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:interpretLtlAST" class="def">interpretLtlAST</a> :: <span class="keyword">forall</span> tags mod m ops a. (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> mod, <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m, <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m tags ops) =&gt; <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> mod ops a -&gt; m a <a href="src/Logic.Ltl.html#interpretLtlAST" class="link">Source</a> <a href="#v:interpretLtlAST" class="selflink">#</a></p><div class="doc"><p>Interpret an <code><a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a></code> into a suitable domain.</p><p>Each effect <code>op</code> in the list <code>ops</code> must have one of the following instances:</p><ul><li><pre>InterpretLtl mod m op</pre></li><li><pre>InterpretLtlHigherOrder mod m op</pre></li><li><pre>InterpretEffectStateful (Const [Ltl mod]) m op</pre></li></ul><p>Which instance is expected is declared through the <code>tags</code>. Since this type
 variable is ambiguous, you will have to type-apply this function to a list
 <code>tags :: [<code><a href="Logic-Ltl.html#t:LtlInstanceKind" title="Logic.Ltl">LtlInstanceKind</a></code>]</code>, which declare, in order, what instance you
 want to use for the operations in <code>ops</code>.</p></div></div><div class="top"><p class="src"><a id="v:interpretLtlASTWithInitialFormulas" class="def">interpretLtlASTWithInitialFormulas</a> :: <span class="keyword">forall</span> tags mod m ops a. (<a href="https://hackage.haskell.org/package/-/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> mod, <a href="https://hackage.haskell.org/package/-/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> m, <a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a> mod m tags ops) =&gt; [<a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a> mod] -&gt; <a href="Logic-Ltl.html#t:LtlAST" title="Logic.Ltl">LtlAST</a> mod ops a -&gt; m a <a href="src/Logic.Ltl.html#interpretLtlASTWithInitialFormulas" class="link">Source</a> <a href="#v:interpretLtlASTWithInitialFormulas" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Logic-Ltl.html#v:interpretLtlAST" title="Logic.Ltl">interpretLtlAST</a></code>, just with an initial list of <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code> formulas that
 will be evaluated throughout the interpretation, even when there are no
 <code><a href="Logic-Ltl.html#v:modifyLtl" title="Logic.Ltl">modifyLtl</a></code>s. Prunes all branches that end with incompletely applied <code><a href="Logic-Ltl.html#t:Ltl" title="Logic.Ltl">Ltl</a></code>
 formulas.</p><p>You'll also have to type-apply this to a list of <code><a href="Logic-Ltl.html#t:LtlInstanceKind" title="Logic.Ltl">LtlInstanceKind</a></code>s, as described ad
 <code><a href="Logic-Ltl.html#v:interpretLtlAST" title="Logic.Ltl">interpretLtlAST</a></code>.</p><p>internal note: This function is the same as <code><a href="Effect-Internal.html#v:interpretASTStateful" title="Effect.Internal">interpretASTStateful</a></code>, just for
 an <code><a href="Logic-Ltl.html#t:InterpretEffectsLtl" title="Logic.Ltl">InterpretEffectsLtl</a></code> constraint instead of <code><a href="Effect-Internal.html#t:InterpretEffectsStateful" title="Effect.Internal">InterpretEffectsStateful</a></code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.27.0</p></div></body></html>